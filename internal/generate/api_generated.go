// Package gen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.3 DO NOT EDIT.
package gen

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	OauthScopes = "oauth.Scopes"
)

// Defines values for BuildpackStateType.
const (
	BuildpackStateTypeAWAITINGUPLOAD BuildpackStateType = "AWAITING_UPLOAD"
	BuildpackStateTypeREADY          BuildpackStateType = "READY"
)

// Defines values for JobState.
const (
	COMPLETE   JobState = "COMPLETE"
	FAILED     JobState = "FAILED"
	POLLING    JobState = "POLLING"
	PROCESSING JobState = "PROCESSING"
)

// Defines values for PackageState.
const (
	PackageStateAWAITINGUPLOAD   PackageState = "AWAITING_UPLOAD"
	PackageStateCOPYING          PackageState = "COPYING"
	PackageStateEXPIRED          PackageState = "EXPIRED"
	PackageStateFAILED           PackageState = "FAILED"
	PackageStatePROCESSINGUPLOAD PackageState = "PROCESSING_UPLOAD"
	PackageStateREADY            PackageState = "READY"
)

// Defines values for PackageType.
const (
	PackageTypeBits   PackageType = "bits"
	PackageTypeDocker PackageType = "docker"
)

// Defines values for PackageCreateRequestBodyType.
const (
	PackageCreateRequestBodyTypeBits   PackageCreateRequestBodyType = "bits"
	PackageCreateRequestBodyTypeDocker PackageCreateRequestBodyType = "docker"
)

// Defines values for RoleCreateType.
const (
	RoleCreateTypeOrganizationAuditor        RoleCreateType = "organization_auditor"
	RoleCreateTypeOrganizationBillingManager RoleCreateType = "organization_billing_manager"
	RoleCreateTypeOrganizationManager        RoleCreateType = "organization_manager"
	RoleCreateTypeOrganizationUser           RoleCreateType = "organization_user"
	RoleCreateTypeSpaceAuditor               RoleCreateType = "space_auditor"
	RoleCreateTypeSpaceDeveloper             RoleCreateType = "space_developer"
	RoleCreateTypeSpaceManager               RoleCreateType = "space_manager"
	RoleCreateTypeSpaceSupporter             RoleCreateType = "space_supporter"
)

// Defines values for RouteDestinationsProtocol.
const (
	RouteDestinationsProtocolHttp1 RouteDestinationsProtocol = "http1"
	RouteDestinationsProtocolHttp2 RouteDestinationsProtocol = "http2"
)

// Defines values for ListRolesParamsTypes.
const (
	ListRolesParamsTypesOrganizationAuditor        ListRolesParamsTypes = "organization_auditor"
	ListRolesParamsTypesOrganizationBillingManager ListRolesParamsTypes = "organization_billing_manager"
	ListRolesParamsTypesOrganizationManager        ListRolesParamsTypes = "organization_manager"
	ListRolesParamsTypesOrganizationUser           ListRolesParamsTypes = "organization_user"
	ListRolesParamsTypesSpaceAuditor               ListRolesParamsTypes = "space_auditor"
	ListRolesParamsTypesSpaceDeveloper             ListRolesParamsTypes = "space_developer"
	ListRolesParamsTypesSpaceManager               ListRolesParamsTypes = "space_manager"
	ListRolesParamsTypesSpaceSupporter             ListRolesParamsTypes = "space_supporter"
)

// Defines values for ListRolesParamsInclude.
const (
	ListRolesParamsIncludeOrganization ListRolesParamsInclude = "organization"
	ListRolesParamsIncludeSpace        ListRolesParamsInclude = "space"
	ListRolesParamsIncludeUser         ListRolesParamsInclude = "user"
)

// Defines values for CreateRoleJSONBodyType.
const (
	OrganizationAuditor        CreateRoleJSONBodyType = "organization_auditor"
	OrganizationBillingManager CreateRoleJSONBodyType = "organization_billing_manager"
	OrganizationManager        CreateRoleJSONBodyType = "organization_manager"
	OrganizationUser           CreateRoleJSONBodyType = "organization_user"
	SpaceAuditor               CreateRoleJSONBodyType = "space_auditor"
	SpaceDeveloper             CreateRoleJSONBodyType = "space_developer"
	SpaceManager               CreateRoleJSONBodyType = "space_manager"
	SpaceSupporter             CreateRoleJSONBodyType = "space_supporter"
)

// Defines values for GetRoleParamsInclude.
const (
	GetRoleParamsIncludeOrganization GetRoleParamsInclude = "organization"
	GetRoleParamsIncludeSpace        GetRoleParamsInclude = "space"
	GetRoleParamsIncludeUser         GetRoleParamsInclude = "user"
)

// Defines values for InsertDestinationsForRouteJSONBodyProtocol.
const (
	InsertDestinationsForRouteJSONBodyProtocolHttp1 InsertDestinationsForRouteJSONBodyProtocol = "http1"
	InsertDestinationsForRouteJSONBodyProtocolHttp2 InsertDestinationsForRouteJSONBodyProtocol = "http2"
)

// Defines values for ReplaceDestinationsForRouteJSONBodyProtocol.
const (
	ReplaceDestinationsForRouteJSONBodyProtocolHttp1 ReplaceDestinationsForRouteJSONBodyProtocol = "http1"
	ReplaceDestinationsForRouteJSONBodyProtocolHttp2 ReplaceDestinationsForRouteJSONBodyProtocol = "http2"
)

// Defines values for UpdateDestinationProtocolForRouteJSONBodyProtocol.
const (
	UpdateDestinationProtocolForRouteJSONBodyProtocolHttp1 UpdateDestinationProtocolForRouteJSONBodyProtocol = "http1"
	UpdateDestinationProtocolForRouteJSONBodyProtocolHttp2 UpdateDestinationProtocolForRouteJSONBodyProtocol = "http2"
)

// App defines model for app.
type App struct {
	// CreatedAt The time the resource was created.
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Guid The GUID of the resource
	Guid *openapi_types.UUID `json:"guid,omitempty"`

	// Lifecycle The lifecycle type defines how the application droplet is created and run. The following lifecycle types are supported: - buildpack: Traditional buildpacks for Cloud Foundry applications. - cnb: Cloud Native Buildpacks that are OCI-compliant. - docker: Run pre-built Docker images.
	Lifecycle *Lifecycle       `json:"lifecycle,omitempty"`
	Links     *map[string]Link `json:"links,omitempty"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Name The name of the app
	Name *string `json:"name,omitempty"`

	// Relationships Relationships represent associations between resources. When relationships are mutable, they can be used to create, read, update, and delete these associations. An app’s relationship to its current droplet is mutable, but an app’s relationship to its space is not.
	//
	// Relationships do not affect the fundamental properties of a resource, but may affect their behavior and permissions logic. Relationships are tied to the lifecycles of the associated resources and will be removed if either of the associated resources are deleted. For example, if a user is removed from an organization, both the user and the organization persist, but the relationship between them does not.
	//
	// Not all resources implement every relationship operation demonstrated in the examples below. See the docs for each resource to see how it interacts with its relationships.
	//
	// Endpoints that return relationship data list this information under the relationships key.
	//
	// The relationship object
	// The relationship object is a key-value pair that uniquely identifies a resource. In practice this is almost always the guid of a resource.
	Relationships *Relationships `json:"relationships,omitempty"`

	// State Current desired state of the app; valid values are STOPPED or STARTED
	State *string `json:"state,omitempty"`

	// UpdatedAt The time the resource was last updated
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// AppFeature App features are used to manage whether optional capabilities are enabled for a given application.
type AppFeature struct {
	// Description The description of the app feature
	Description *string `json:"description,omitempty"`

	// Enabled Whether the app feature is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// Name The name of the app feature
	Name *string `json:"name,omitempty"`
}

// AppFeatureList defines model for appFeatureList.
type AppFeatureList struct {
	// Pagination Pagination is a technique used to divide a large set of results into smaller, more manageable sets. This allows clients to retrieve results in smaller chunks, reducing the amount of data transferred and improving performance.
	// The pagination object is a JSON object that contains information about the pagination state of the results. It includes the total number of results available, the total number of pages available, and links to the first, last, next, and previous pages of results.
	Pagination *Pagination   `json:"pagination,omitempty"`
	Resources  *[]AppFeature `json:"resources,omitempty"`
}

// AppList defines model for appList.
type AppList struct {
	// Pagination Pagination is a technique used to divide a large set of results into smaller, more manageable sets. This allows clients to retrieve results in smaller chunks, reducing the amount of data transferred and improving performance.
	// The pagination object is a JSON object that contains information about the pagination state of the results. It includes the total number of results available, the total number of pages available, and links to the first, last, next, and previous pages of results.
	Pagination *Pagination `json:"pagination,omitempty"`
	Resources  *[]App      `json:"resources,omitempty"`
}

// AppUsageEvent A resource represents an individual object within the system, such as an app or a service. It is represented as a JSON object.
// A resource consists of several required resource fields and other attributes specific to the resource.
// See Resources and Experimental Resources for specific resources.
type AppUsageEvent = BaseSchema

// AppUsageEventList defines model for appUsageEventList.
type AppUsageEventList struct {
	// Pagination Pagination is a technique used to divide a large set of results into smaller, more manageable sets. This allows clients to retrieve results in smaller chunks, reducing the amount of data transferred and improving performance.
	// The pagination object is a JSON object that contains information about the pagination state of the results. It includes the total number of results available, the total number of pages available, and links to the first, last, next, and previous pages of results.
	Pagination *Pagination      `json:"pagination,omitempty"`
	Resources  *[]AppUsageEvent `json:"resources,omitempty"`
}

// AuditEvent defines model for auditEvent.
type AuditEvent struct {
	Actor *struct {
		// Guid The unique identifier for the actor (user or system resource that performed the action)
		Guid *string `json:"guid,omitempty"`

		// Name The name of the actor
		Name *string `json:"name,omitempty"`

		// Type The actor type
		Type *string `json:"type,omitempty"`
	} `json:"actor,omitempty"`

	// CreatedAt The time the resource was created.
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Data Additional information about the event
	Data *map[string]interface{} `json:"data,omitempty"`

	// Guid The GUID of the resource
	Guid *openapi_types.UUID `json:"guid,omitempty"`

	// Links Links provide URLs to relationships and actions for a resource. Links are represented as a JSON object and always contain a self link.
	Links        *Links `json:"links,omitempty"`
	Organization *struct {
		// Guid The unique identifier for the organization where the event occurred
		Guid *string `json:"guid,omitempty"`
	} `json:"organization,omitempty"`
	Space *struct {
		// Guid The unique identifier for the space where the event occurred
		Guid *string `json:"guid,omitempty"`
	} `json:"space,omitempty"`
	Target *struct {
		// Guid The unique identifier for the target (resource that the event acted upon)
		Guid *string `json:"guid,omitempty"`

		// Name The name of the target
		Name *string `json:"name,omitempty"`

		// Type The target type
		Type *string `json:"type,omitempty"`
	} `json:"target,omitempty"`

	// Type The type of the event
	Type *string `json:"type,omitempty"`

	// UpdatedAt The time the resource was last updated
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// AuditEventList defines model for auditEventList.
type AuditEventList struct {
	// Pagination Pagination is a technique used to divide a large set of results into smaller, more manageable sets. This allows clients to retrieve results in smaller chunks, reducing the amount of data transferred and improving performance.
	// The pagination object is a JSON object that contains information about the pagination state of the results. It includes the total number of results available, the total number of pages available, and links to the first, last, next, and previous pages of results.
	Pagination *Pagination   `json:"pagination,omitempty"`
	Resources  *[]AuditEvent `json:"resources,omitempty"`
}

// BaseSchema A resource represents an individual object within the system, such as an app or a service. It is represented as a JSON object.
// A resource consists of several required resource fields and other attributes specific to the resource.
// See Resources and Experimental Resources for specific resources.
type BaseSchema struct {
	// CreatedAt The time the resource was created.
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Guid The GUID of the resource
	Guid  *openapi_types.UUID `json:"guid,omitempty"`
	Links *map[string]Link    `json:"links,omitempty"`

	// UpdatedAt The time the resource was last updated
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Build defines model for build.
type Build struct {
	Checksum *struct {
		// Type Hashing algorithm for checksum; supported algorithms are sha256 and sha1
		Type *string `json:"type,omitempty"`

		// Value Checksum of build
		Value *string `json:"value,omitempty"`
	} `json:"checksum,omitempty"`

	// CreatedAt The time the resource was created.
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	CreatedAt *time.Time `json:"created_at,omitempty"`
	CreatedBy *struct {
		// Email The email of the user that created the build
		Email *string `json:"email,omitempty"`

		// Guid The GUID of the user that created the build
		Guid *string `json:"guid,omitempty"`

		// Name The name of the user that created the build
		Name *string `json:"name,omitempty"`
	} `json:"created_by,omitempty"`

	// Droplet Some relationships relate a resource to exactly one other resource. For example an app can belong to only one space.
	Droplet *RelationshipToOne `json:"droplet,omitempty"`

	// Error A string describing errors during the build process
	Error *string `json:"error,omitempty"`

	// Guid The GUID of the resource
	Guid *openapi_types.UUID `json:"guid,omitempty"`

	// Lifecycle The lifecycle type defines how the application droplet is created and run. The following lifecycle types are supported: - buildpack: Traditional buildpacks for Cloud Foundry applications. - cnb: Cloud Native Buildpacks that are OCI-compliant. - docker: Run pre-built Docker images.
	Lifecycle *Lifecycle `json:"lifecycle,omitempty"`

	// Links Links provide URLs to relationships and actions for a resource. Links are represented as a JSON object and always contain a self link.
	Links *Links `json:"links,omitempty"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Relationships Relationships represent associations between resources. When relationships are mutable, they can be used to create, read, update, and delete these associations. An app’s relationship to its current droplet is mutable, but an app’s relationship to its space is not.
	//
	// Relationships do not affect the fundamental properties of a resource, but may affect their behavior and permissions logic. Relationships are tied to the lifecycles of the associated resources and will be removed if either of the associated resources are deleted. For example, if a user is removed from an organization, both the user and the organization persist, but the relationship between them does not.
	//
	// Not all resources implement every relationship operation demonstrated in the examples below. See the docs for each resource to see how it interacts with its relationships.
	//
	// Endpoints that return relationship data list this information under the relationships key.
	//
	// The relationship object
	// The relationship object is a key-value pair that uniquely identifies a resource. In practice this is almost always the guid of a resource.
	Relationships *Relationships `json:"relationships,omitempty"`

	// StagingDiskInMb Disk space in MB allocated for staging of the build
	StagingDiskInMb *int `json:"staging_disk_in_mb,omitempty"`

	// StagingLogRateLimitBytesPerSecond Log rate limit in bytes per second allocated for staging of the build
	StagingLogRateLimitBytesPerSecond *int `json:"staging_log_rate_limit_bytes_per_second,omitempty"`

	// StagingMemoryInMb Memory in MB allocated for staging of the build
	StagingMemoryInMb *int `json:"staging_memory_in_mb,omitempty"`

	// State State of the build; valid states are STAGING, STAGED, or FAILED
	State *string `json:"state,omitempty"`

	// UpdatedAt The time the resource was last updated
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// BuildList defines model for buildList.
type BuildList struct {
	// Pagination Pagination is a technique used to divide a large set of results into smaller, more manageable sets. This allows clients to retrieve results in smaller chunks, reducing the amount of data transferred and improving performance.
	// The pagination object is a JSON object that contains information about the pagination state of the results. It includes the total number of results available, the total number of pages available, and links to the first, last, next, and previous pages of results.
	Pagination *Pagination `json:"pagination,omitempty"`
	Resources  *[]Build    `json:"resources,omitempty"`
}

// Buildpack defines model for buildpack.
type Buildpack struct {
	// CreatedAt The time the resource was created.
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Enabled Whether the buildpack is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// Filename The filename of the buildpack
	Filename *string `json:"filename,omitempty"`

	// Guid The GUID of the resource
	Guid  *openapi_types.UUID `json:"guid,omitempty"`
	Links *Links              `json:"links,omitempty"`

	// Locked Whether the buildpack is locked
	Locked *bool `json:"locked,omitempty"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Name The name of the buildpack
	Name *string `json:"name,omitempty"`

	// Position The position of the buildpack in the order of execution
	Position *int `json:"position,omitempty"`

	// Stack The stack the buildpack is compatible with
	Stack *string `json:"stack,omitempty"`

	// UpdatedAt The time the resource was last updated
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// BuildpackList defines model for buildpackList.
type BuildpackList struct {
	// Pagination Pagination is a technique used to divide a large set of results into smaller, more manageable sets. This allows clients to retrieve results in smaller chunks, reducing the amount of data transferred and improving performance.
	// The pagination object is a JSON object that contains information about the pagination state of the results. It includes the total number of results available, the total number of pages available, and links to the first, last, next, and previous pages of results.
	Pagination *Pagination  `json:"pagination,omitempty"`
	Resources  *[]Buildpack `json:"resources,omitempty"`
}

// BuildpackStateType Possible states of a buildpack
type BuildpackStateType string

// Deployment defines model for deployment.
type Deployment struct {
	// CreatedAt The time the resource was created.
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Droplet Some relationships relate a resource to exactly one other resource. For example an app can belong to only one space.
	Droplet *RelationshipToOne `json:"droplet,omitempty"`

	// Guid The GUID of the resource
	Guid *openapi_types.UUID `json:"guid,omitempty"`

	// Links Links provide URLs to relationships and actions for a resource. Links are represented as a JSON object and always contain a self link.
	Links *Links `json:"links,omitempty"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata     *Metadata `json:"metadata,omitempty"`
	NewProcesses *[]struct {
		// Guid The GUID of the new process created as part of the deployment
		Guid *openapi_types.UUID `json:"guid,omitempty"`

		// Type The type of the new process created as part of the deployment
		Type *string `json:"type,omitempty"`
	} `json:"new_processes,omitempty"`
	Options *struct {
		// MaxInFlight The maximum number of new instances to deploy simultaneously
		MaxInFlight *int `json:"max_in_flight,omitempty"`
	} `json:"options,omitempty"`

	// PreviousDroplet Some relationships relate a resource to exactly one other resource. For example an app can belong to only one space.
	PreviousDroplet *RelationshipToOne `json:"previous_droplet,omitempty"`

	// Relationships Relationships represent associations between resources. When relationships are mutable, they can be used to create, read, update, and delete these associations. An app’s relationship to its current droplet is mutable, but an app’s relationship to its space is not.
	//
	// Relationships do not affect the fundamental properties of a resource, but may affect their behavior and permissions logic. Relationships are tied to the lifecycles of the associated resources and will be removed if either of the associated resources are deleted. For example, if a user is removed from an organization, both the user and the organization persist, but the relationship between them does not.
	//
	// Not all resources implement every relationship operation demonstrated in the examples below. See the docs for each resource to see how it interacts with its relationships.
	//
	// Endpoints that return relationship data list this information under the relationships key.
	//
	// The relationship object
	// The relationship object is a key-value pair that uniquely identifies a resource. In practice this is almost always the guid of a resource.
	Relationships *Relationships `json:"relationships,omitempty"`
	Revision      *struct {
		// Guid The revision the deployment is transitioning the app to
		Guid *openapi_types.UUID `json:"guid,omitempty"`

		// Version The version of the revision
		Version *int `json:"version,omitempty"`
	} `json:"revision,omitempty"`
	Status *struct {
		Details *struct {
			// LastStatusChange Timestamp of last change to status.value or status.reason
			LastStatusChange *time.Time `json:"last_status_change,omitempty"`

			// LastSuccessfulHealthcheck Timestamp of the last successful health check
			LastSuccessfulHealthcheck *time.Time `json:"last_successful_healthcheck,omitempty"`
		} `json:"details,omitempty"`

		// Reason The reason for the status of the deployment
		Reason *string `json:"reason,omitempty"`

		// Value The current status of the deployment; valid values are ACTIVE (in progress) and FINALIZED (finished, either successfully or not)
		Value *string `json:"value,omitempty"`
	} `json:"status,omitempty"`

	// Strategy Strategy used for the deployment; supported strategies are rolling and canary (experimental)
	Strategy *string `json:"strategy,omitempty"`

	// UpdatedAt The time the resource was last updated
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// DeploymentList defines model for deploymentList.
type DeploymentList struct {
	// Pagination Pagination is a technique used to divide a large set of results into smaller, more manageable sets. This allows clients to retrieve results in smaller chunks, reducing the amount of data transferred and improving performance.
	// The pagination object is a JSON object that contains information about the pagination state of the results. It includes the total number of results available, the total number of pages available, and links to the first, last, next, and previous pages of results.
	Pagination *Pagination   `json:"pagination,omitempty"`
	Resources  *[]Deployment `json:"resources,omitempty"`
}

// Domain defines model for domain.
type Domain struct {
	// CreatedAt The time the resource was created.
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Guid The GUID of the resource
	Guid *openapi_types.UUID `json:"guid,omitempty"`

	// Internal Whether the domain is used for internal (container-to-container) traffic
	Internal *bool `json:"internal,omitempty"`

	// Links Links provide URLs to relationships and actions for a resource. Links are represented as a JSON object and always contain a self link.
	Links *Links `json:"links,omitempty"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Name The name of the domain; must be between 3-253 characters and follow RFC 1035
	Name *string `json:"name,omitempty"`

	// Relationships Relationships represent associations between resources. When relationships are mutable, they can be used to create, read, update, and delete these associations. An app’s relationship to its current droplet is mutable, but an app’s relationship to its space is not.
	//
	// Relationships do not affect the fundamental properties of a resource, but may affect their behavior and permissions logic. Relationships are tied to the lifecycles of the associated resources and will be removed if either of the associated resources are deleted. For example, if a user is removed from an organization, both the user and the organization persist, but the relationship between them does not.
	//
	// Not all resources implement every relationship operation demonstrated in the examples below. See the docs for each resource to see how it interacts with its relationships.
	//
	// Endpoints that return relationship data list this information under the relationships key.
	//
	// The relationship object
	// The relationship object is a key-value pair that uniquely identifies a resource. In practice this is almost always the guid of a resource.
	Relationships *Relationships `json:"relationships,omitempty"`

	// RouterGroup The router group that the domain will use for TCP traffic
	RouterGroup *struct {
		// Guid The GUID of the router group to route TCP traffic through
		Guid *openapi_types.UUID `json:"guid,omitempty"`
	} `json:"router_group,omitempty"`

	// SupportedProtocols Available protocols for routes using the domain, currently http and tcp
	SupportedProtocols *[]string `json:"supported_protocols,omitempty"`

	// UpdatedAt The time the resource was last updated
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// DomainList defines model for domainList.
type DomainList struct {
	// Pagination Pagination is a technique used to divide a large set of results into smaller, more manageable sets. This allows clients to retrieve results in smaller chunks, reducing the amount of data transferred and improving performance.
	// The pagination object is a JSON object that contains information about the pagination state of the results. It includes the total number of results available, the total number of pages available, and links to the first, last, next, and previous pages of results.
	Pagination *Pagination `json:"pagination,omitempty"`
	Resources  *[]Domain   `json:"resources,omitempty"`
}

// Droplet defines model for droplet.
type Droplet struct {
	Buildpacks *[]struct {
		// BuildpackName Name reported by the buildpack
		BuildpackName *string `json:"buildpack_name,omitempty"`

		// DetectOutput Output during buildpack detect process
		DetectOutput *string `json:"detect_output,omitempty"`

		// Name System buildpack name
		Name *string `json:"name,omitempty"`

		// Version Version reported by the buildpack
		Version *string `json:"version,omitempty"`
	} `json:"buildpacks,omitempty"`
	Checksum *struct {
		// Type Hashing algorithm for checksum; supported algorithms are sha256 and sha1
		Type *string `json:"type,omitempty"`

		// Value Checksum of the droplet
		Value *string `json:"value,omitempty"`
	} `json:"checksum,omitempty"`

	// CreatedAt The time the resource was created.
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Error A string describing the last error during the droplet lifecycle
	Error *string `json:"error,omitempty"`

	// ExecutionMetadata Serialized JSON data resulting from staging for use when executing a droplet
	ExecutionMetadata *string `json:"execution_metadata,omitempty"`

	// Guid The GUID of the resource
	Guid *openapi_types.UUID `json:"guid,omitempty"`

	// Image Docker image name for Docker droplets
	Image *string `json:"image,omitempty"`

	// Lifecycle The lifecycle type defines how the application droplet is created and run. The following lifecycle types are supported: - buildpack: Traditional buildpacks for Cloud Foundry applications. - cnb: Cloud Native Buildpacks that are OCI-compliant. - docker: Run pre-built Docker images.
	Lifecycle *Lifecycle `json:"lifecycle,omitempty"`
	Links     *struct {
		AssignCurrentDroplet *struct {
			// Href The URL of the link
			Href string `json:"href"`

			// Method An optional field containing the HTTP method to be used when following the URL
			Method *string `json:"method,omitempty"`
		} `json:"assign_current_droplet,omitempty"`
		Download *struct {
			// Href The URL of the link
			Href string `json:"href"`

			// Method An optional field containing the HTTP method to be used when following the URL
			Method *string `json:"method,omitempty"`
		} `json:"download,omitempty"`
	} `json:"links,omitempty"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// ProcessTypes The process types (keys) and associated start commands (values) that will be created when the droplet is executed
	ProcessTypes *map[string]interface{} `json:"process_types,omitempty"`

	// Stack The root filesystem to use with the buildpack, for example cflinuxfs4
	Stack *string `json:"stack,omitempty"`

	// State State of the droplet; valid states are AWAITING_UPLOAD, PROCESSING_UPLOAD, STAGED, COPYING, FAILED, or EXPIRED
	State *string `json:"state,omitempty"`

	// UpdatedAt The time the resource was last updated
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// DropletList defines model for dropletList.
type DropletList struct {
	// Pagination Pagination is a technique used to divide a large set of results into smaller, more manageable sets. This allows clients to retrieve results in smaller chunks, reducing the amount of data transferred and improving performance.
	// The pagination object is a JSON object that contains information about the pagination state of the results. It includes the total number of results available, the total number of pages available, and links to the first, last, next, and previous pages of results.
	Pagination *Pagination `json:"pagination,omitempty"`
	Resources  *[]Droplet  `json:"resources,omitempty"`
}

// EnvironmentVariableGroup Environment variable groups allow platform operators/admins to manage environment variables across all apps in a Cloud Foundry foundation. Variables in the running environment variable group will be injected into all running app containers. Variables in the staging environment variable group will be injected into the staging container for all apps while they are being staged.
type EnvironmentVariableGroup struct {
	// Links Links provide URLs to relationships and actions for a resource. Links are represented as a JSON object and always contain a self link.
	Links *Links `json:"links,omitempty"`

	// Name The name of the group; can only be "running" or "staging"
	Name *string `json:"name,omitempty"`

	// UpdatedAt The time the environment variable group was last updated
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Var Environment variables to inject; keys and values must be strings
	Var *map[string]string `json:"var,omitempty"`
}

// Error defines model for error.
type Error struct {
	// Code A numeric code for this error
	Code *int `json:"code,omitempty"`

	// Detail Detailed description of the error
	Detail *string `json:"detail,omitempty"`

	// Title Name of the error
	Title *string `json:"title,omitempty"`
}

// Errors An error response will always return a list of error objects. Errors appear on the job resource for asynchronous operations.
// Clients should use the code and title fields for programmatically handling specific errors. The message in the detail field is subject to change over time.
type Errors struct {
	Errors *[]struct {
		// Code A numeric code for this error
		Code *int `json:"code,omitempty"`

		// Detail Detailed description of the error
		Detail *string `json:"detail,omitempty"`

		// Title Name of the error
		Title *string `json:"title,omitempty"`
	} `json:"errors,omitempty"`
}

// FeatureFlag Feature flags are runtime flags that enable or disable functionality on the API.
type FeatureFlag struct {
	// CustomErrorMessage The error string returned by the API when a client performs an action disabled by the feature flag
	CustomErrorMessage *string `json:"custom_error_message,omitempty"`

	// Enabled Whether the feature flag is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// Links Links provide URLs to relationships and actions for a resource. Links are represented as a JSON object and always contain a self link.
	Links *Links `json:"links,omitempty"`

	// Name The name of the feature flag
	Name *string `json:"name,omitempty"`

	// UpdatedAt The time the feature flag was last updated; this will be blank for feature flags that have not been configured
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// FeatureFlagList defines model for featureFlagList.
type FeatureFlagList struct {
	// Pagination Pagination is a technique used to divide a large set of results into smaller, more manageable sets. This allows clients to retrieve results in smaller chunks, reducing the amount of data transferred and improving performance.
	// The pagination object is a JSON object that contains information about the pagination state of the results. It includes the total number of results available, the total number of pages available, and links to the first, last, next, and previous pages of results.
	Pagination *Pagination    `json:"pagination,omitempty"`
	Resources  *[]FeatureFlag `json:"resources,omitempty"`
}

// IsolationSegment defines model for isolationSegment.
type IsolationSegment struct {
	// CreatedAt The time the resource was created.
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Guid The GUID of the resource
	Guid  *openapi_types.UUID `json:"guid,omitempty"`
	Links *struct {
		Organizations *struct {
			// Href The URL of the link
			Href string `json:"href"`

			// Method An optional field containing the HTTP method to be used when following the URL
			Method *string `json:"method,omitempty"`
		} `json:"organizations,omitempty"`
	} `json:"links,omitempty"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Name The name of the isolation segment
	Name *string `json:"name,omitempty"`

	// UpdatedAt The time the resource was last updated
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// IsolationSegmentList defines model for isolationSegmentList.
type IsolationSegmentList struct {
	// Pagination Pagination is a technique used to divide a large set of results into smaller, more manageable sets. This allows clients to retrieve results in smaller chunks, reducing the amount of data transferred and improving performance.
	// The pagination object is a JSON object that contains information about the pagination state of the results. It includes the total number of results available, the total number of pages available, and links to the first, last, next, and previous pages of results.
	Pagination *Pagination         `json:"pagination,omitempty"`
	Resources  *[]IsolationSegment `json:"resources,omitempty"`
}

// Job defines model for job.
type Job struct {
	// CreatedAt The time the resource was created.
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Errors Any errors encountered during job execution
	Errors *[]Error `json:"errors,omitempty"`

	// Guid The GUID of the resource
	Guid  *openapi_types.UUID `json:"guid,omitempty"`
	Links *Links              `json:"links,omitempty"`

	// Operation The type of operation the job is performing
	Operation *string `json:"operation,omitempty"`

	// State The current state of the job
	State *JobState `json:"state,omitempty"`

	// UpdatedAt The time the resource was last updated
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Warnings Any warnings encountered during job execution
	Warnings *[]Warning `json:"warnings,omitempty"`
}

// JobState The current state of the job
type JobState string

// JobList defines model for jobList.
type JobList struct {
	// Pagination Pagination is a technique used to divide a large set of results into smaller, more manageable sets. This allows clients to retrieve results in smaller chunks, reducing the amount of data transferred and improving performance.
	// The pagination object is a JSON object that contains information about the pagination state of the results. It includes the total number of results available, the total number of pages available, and links to the first, last, next, and previous pages of results.
	Pagination *Pagination `json:"pagination,omitempty"`
	Resources  *[]Job      `json:"resources,omitempty"`
}

// Lifecycle The lifecycle type defines how the application droplet is created and run. The following lifecycle types are supported: - buildpack: Traditional buildpacks for Cloud Foundry applications. - cnb: Cloud Native Buildpacks that are OCI-compliant. - docker: Run pre-built Docker images.
type Lifecycle struct {
	// Data Data specific to the lifecycle
	Data *Lifecycle_Data `json:"data,omitempty"`

	// Type Type of the lifecycle; valid values are buildpack, cnb, docker
	Type *string `json:"type,omitempty"`
}

// Lifecycle_Data Data specific to the lifecycle
type Lifecycle_Data struct {
	// Buildpacks List of the names of buildpacks, URLs from which they may be downloaded, or null to auto-detect a suitable buildpack during staging (applicable for buildpack and cnb lifecycles)
	Buildpacks *[]string `json:"buildpacks,omitempty"`

	// Credentials Credentials used to download the configured buildpacks (applicable for cnb lifecycle)
	Credentials *map[string]struct {
		Password *string `json:"password,omitempty"`
		Token    *string `json:"token,omitempty"`
		Username *string `json:"username,omitempty"`
	} `json:"credentials,omitempty"`

	// Stack The root filesystem to use with the buildpack, for example cflinuxfs4 (applicable for buildpack lifecycle)
	Stack                *string                `json:"stack,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Link Each link is keyed by its type and will include a href for the URL and an optional method for links that cannot be followed using GET.
type Link struct {
	// Href The URL of the link
	Href string `json:"href"`

	// Method An optional field containing the HTTP method to be used when following the URL
	Method *string `json:"method,omitempty"`
}

// Links Links provide URLs to relationships and actions for a resource. Links are represented as a JSON object and always contain a self link.
type Links = map[string]interface{}

// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
// Metadata is included in the response body of a request to retrieve a resource.
type Metadata struct {
	// Annotations A set of key-value pairs that describe the resource. Annotations are a JSON object that contains information about a resource. They are used to tag resources with metadata that can be used to filter and group resources. Annotations are included in the response body of a request to retrieve a resource.
	// Annotations are user-specified key-value pairs that are attached to API resources. They do not affect the operation of Cloud Foundry. Annotations cannot be used in filters.
	//
	// When a service instance is being created, the service broker is sent the annotations of the service instance, and the space and organization in which the service instance resides. When a service instance is being updated, the service broker is sent the annotations of the space and organization in which the service instance resides. When a service binding is being created, the service broker is sent annotations of any associated app, and the space and organization in which the binding resides. Only annotations with a prefix (e.g. company.com/contacts) are sent to service brokers.
	//
	// Examples may include (but are not limited to):
	//
	// "contact info": "bob@example.com jane@example.com"
	// "library versions": "Spring: 5.1, Redis Client: a184098. yaml parser: 38"
	// "git-sha": "d56fe0367554ae5e878e37ed6c5b9a82f5995512"
	// Annotation keys
	// Annotation keys are made up of an (optional) prefix and name. If a prefix is present, it is separated from the name by a /. Prefixes are DNS names intended to enable namespacing of annotation keys.
	//
	// An annotation key prefix must adhere to the following restrictions:
	//
	// Length: 0-253 characters
	// Allowed characters: a-z, A-Z, 0-9, -, and .; emojis cannot be used in keys
	// DNS subdomain format (series of subdomain annotations separated by .)
	// An annotation key name must adhere to the following restrictions:
	//
	// Length: 1-63 characters
	// Allowed characters: a-z, A-Z, 0-9, -, _, and .; emojis cannot be used in keys
	// Must begin and end with an alphanumeric character
	// Annotation values
	// Annotation values must adhere to the following restrictions:
	//
	// Length: 0-5000 unicode characters
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Labels A set of key-value pairs that describe the resource. Labels are a JSON object that contains information about a resource. They are used to tag resources with metadata that can be used to filter and group resources. Labels are included in the response body of a request to retrieve a resource.
	// Labels are user-specified key/value pairs that are attached to API Resources. They are queryable, identifying attributes of a resource, but they do not affect the operation of CloudFoundry.
	//
	// For example, an app may be assigned a label with key sensitive and possible values true or false.
	//
	// Users could then find all sensitive apps with a selector for sensitive=true, resulting in a response containing only apps having the label key sensitive with a label value of true.
	//
	// Labels
	// Labels allow users to apply identifying attributes to resources that are meaningful to the user, but not the CloudFoundry system.
	//
	// Examples may include (but are not limited to):
	//
	// "production" : "true" or "production" : "false"
	// "env" : "dev" or "env" : "test" or "env" : "prod"
	// "chargeback-code" : "abc123"
	// Label keys
	// Label keys are made up of an (optional) prefix, and name. If a prefix is present, it is separated from the name by a /. Prefixes are dns names intended to enable namespacing of label keys.
	//
	// A label key prefix must adhere to the following restrictions:
	//
	// Length: 0-253 characters
	// Allowed characters: alphanumeric ( [a-z0-9A-Z] ), -, and .
	// DNS subdomain format (series of subdomain labels separated by .)
	// A label key name must adhere to the following restrictions:
	//
	// Length: 1-63 characters
	// Allowed characters: alphanumeric ( [a-z0-9A-Z] ), -, _, and .
	// Must begin and end with an alphanumeric character
	// Label values
	// Label values must adhere to the following restrictions:
	//
	// Length: 0-63 characters
	// Allowed characters: alphanumeric ( [a-z0-9A-Z] ), -, _, and .
	// Must begin and end with an alphanumeric character
	// Empty values are allowed
	Labels *map[string]string `json:"labels,omitempty"`
}

// Package defines model for package.
type Package struct {
	// CreatedAt The time the resource was created.
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Data Data for package type
	Data *struct {
		Checksum *struct {
			// Type The checksum type, for example sha256
			Type *string `json:"type,omitempty"`

			// Value The checksum value; this will be populated after bits are uploaded
			Value *string `json:"value,omitempty"`
		} `json:"checksum,omitempty"`

		// Error If an error occurs this field will contain the error message
		Error *string `json:"error,omitempty"`

		// Image The registry address of the image
		Image *string `json:"image,omitempty"`

		// Password The password for the image's registry
		Password *string `json:"password,omitempty"`

		// Username The username for the image's registry
		Username *string `json:"username,omitempty"`
	} `json:"data,omitempty"`

	// Guid The GUID of the resource
	Guid  *openapi_types.UUID `json:"guid,omitempty"`
	Links *struct {
		Download *struct {
			// Href The URL of the link
			Href string `json:"href"`

			// Method An optional field containing the HTTP method to be used when following the URL
			Method *string `json:"method,omitempty"`
		} `json:"download,omitempty"`
		Stage *struct {
			// Href The URL of the link
			Href string `json:"href"`

			// Method An optional field containing the HTTP method to be used when following the URL
			Method *string `json:"method,omitempty"`
		} `json:"stage,omitempty"`
		Upload *struct {
			// Href The URL of the link
			Href string `json:"href"`

			// Method An optional field containing the HTTP method to be used when following the URL
			Method *string `json:"method,omitempty"`
		} `json:"upload,omitempty"`
	} `json:"links,omitempty"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Relationships Relationships represent associations between resources. When relationships are mutable, they can be used to create, read, update, and delete these associations. An app’s relationship to its current droplet is mutable, but an app’s relationship to its space is not.
	//
	// Relationships do not affect the fundamental properties of a resource, but may affect their behavior and permissions logic. Relationships are tied to the lifecycles of the associated resources and will be removed if either of the associated resources are deleted. For example, if a user is removed from an organization, both the user and the organization persist, but the relationship between them does not.
	//
	// Not all resources implement every relationship operation demonstrated in the examples below. See the docs for each resource to see how it interacts with its relationships.
	//
	// Endpoints that return relationship data list this information under the relationships key.
	//
	// The relationship object
	// The relationship object is a key-value pair that uniquely identifies a resource. In practice this is almost always the guid of a resource.
	Relationships *Relationships `json:"relationships,omitempty"`

	// State State of the package; valid states are AWAITING_UPLOAD, PROCESSING_UPLOAD, READY, FAILED, COPYING, or EXPIRED
	State *PackageState `json:"state,omitempty"`

	// Type Type of the package; valid values are bits or docker
	Type *PackageType `json:"type,omitempty"`

	// UpdatedAt The time the resource was last updated
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// PackageState State of the package; valid states are AWAITING_UPLOAD, PROCESSING_UPLOAD, READY, FAILED, COPYING, or EXPIRED
type PackageState string

// PackageType Type of the package; valid values are bits or docker
type PackageType string

// PackageCreateRequestBodyType Valid package types
type PackageCreateRequestBodyType string

// PackageList defines model for packageList.
type PackageList struct {
	// Pagination Pagination is a technique used to divide a large set of results into smaller, more manageable sets. This allows clients to retrieve results in smaller chunks, reducing the amount of data transferred and improving performance.
	// The pagination object is a JSON object that contains information about the pagination state of the results. It includes the total number of results available, the total number of pages available, and links to the first, last, next, and previous pages of results.
	Pagination *Pagination `json:"pagination,omitempty"`
	Resources  *[]Package  `json:"resources,omitempty"`
}

// PaginatedUsers defines model for paginated_users.
type PaginatedUsers struct {
	// CreatedAt The time the resource was created.
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Guid The GUID of the resource
	Guid  *openapi_types.UUID `json:"guid,omitempty"`
	Links *map[string]Link    `json:"links,omitempty"`

	// Pagination Pagination is a technique used to divide a large set of results into smaller, more manageable sets. This allows clients to retrieve results in smaller chunks, reducing the amount of data transferred and improving performance.
	// The pagination object is a JSON object that contains information about the pagination state of the results. It includes the total number of results available, the total number of pages available, and links to the first, last, next, and previous pages of results.
	Pagination *Pagination `json:"pagination,omitempty"`
	Resources  *[]User     `json:"resources,omitempty"`

	// UpdatedAt The time the resource was last updated
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Pagination Pagination is a technique used to divide a large set of results into smaller, more manageable sets. This allows clients to retrieve results in smaller chunks, reducing the amount of data transferred and improving performance.
// The pagination object is a JSON object that contains information about the pagination state of the results. It includes the total number of results available, the total number of pages available, and links to the first, last, next, and previous pages of results.
type Pagination struct {
	First *struct {
		// Href The URL of the link
		Href string `json:"href"`

		// Method An optional field containing the HTTP method to be used when following the URL
		Method *string `json:"method,omitempty"`
	} `json:"first,omitempty"`
	Last *struct {
		// Href The URL of the link
		Href string `json:"href"`

		// Method An optional field containing the HTTP method to be used when following the URL
		Method *string `json:"method,omitempty"`
	} `json:"last,omitempty"`
	Next *struct {
		// Href The URL of the link
		Href string `json:"href"`

		// Method An optional field containing the HTTP method to be used when following the URL
		Method *string `json:"method,omitempty"`
	} `json:"next,omitempty"`
	Previous *struct {
		// Href The URL of the link
		Href string `json:"href"`

		// Method An optional field containing the HTTP method to be used when following the URL
		Method *string `json:"method,omitempty"`
	} `json:"previous,omitempty"`

	// TotalPages The total number of pages available
	TotalPages *int `json:"total_pages,omitempty"`

	// TotalResults The total number of results available
	TotalResults *int `json:"total_results,omitempty"`
}

// Relationship defines model for relationship.
type Relationship struct {
	// Guid The GUID of the resource
	Guid *openapi_types.UUID `json:"guid,omitempty"`
}

// RelationshipToMany Some relationships relate a resource to several other resources. For example, an isolation segment can be entitled to multiple organizations.
type RelationshipToMany struct {
	Data *[]Relationship `json:"data,omitempty"`
}

// RelationshipToOne Some relationships relate a resource to exactly one other resource. For example an app can belong to only one space.
type RelationshipToOne struct {
	Data *Relationship `json:"data,omitempty"`
}

// Relationships Relationships represent associations between resources. When relationships are mutable, they can be used to create, read, update, and delete these associations. An app’s relationship to its current droplet is mutable, but an app’s relationship to its space is not.
//
// Relationships do not affect the fundamental properties of a resource, but may affect their behavior and permissions logic. Relationships are tied to the lifecycles of the associated resources and will be removed if either of the associated resources are deleted. For example, if a user is removed from an organization, both the user and the organization persist, but the relationship between them does not.
//
// Not all resources implement every relationship operation demonstrated in the examples below. See the docs for each resource to see how it interacts with its relationships.
//
// Endpoints that return relationship data list this information under the relationships key.
//
// The relationship object
// The relationship object is a key-value pair that uniquely identifies a resource. In practice this is almost always the guid of a resource.
type Relationships = map[string]interface{}

// Revision defines model for revision.
type Revision struct {
	// CreatedAt The time the resource was created.
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Description Description of the revision, created by the user
	Description *string `json:"description,omitempty"`

	// Droplet Some relationships relate a resource to exactly one other resource. For example an app can belong to only one space.
	Droplet *RelationshipToOne `json:"droplet,omitempty"`

	// Enabled Whether the revision is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// Guid The GUID of the resource
	Guid  *openapi_types.UUID `json:"guid,omitempty"`
	Links *struct {
		EnvironmentVariables *struct {
			// Href The URL of the link
			Href string `json:"href"`

			// Method An optional field containing the HTTP method to be used when following the URL
			Method *string `json:"method,omitempty"`
		} `json:"environment_variables,omitempty"`
	} `json:"links,omitempty"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata      *Metadata `json:"metadata,omitempty"`
	Relationships *struct {
		// App Some relationships relate a resource to exactly one other resource. For example an app can belong to only one space.
		App *RelationshipToOne `json:"app,omitempty"`
	} `json:"relationships,omitempty"`

	// UpdatedAt The time the resource was last updated
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Version Version number of the revision
	Version *int `json:"version,omitempty"`
}

// RevisionList defines model for revisionList.
type RevisionList struct {
	// Pagination Pagination is a technique used to divide a large set of results into smaller, more manageable sets. This allows clients to retrieve results in smaller chunks, reducing the amount of data transferred and improving performance.
	// The pagination object is a JSON object that contains information about the pagination state of the results. It includes the total number of results available, the total number of pages available, and links to the first, last, next, and previous pages of results.
	Pagination *Pagination `json:"pagination,omitempty"`
	Resources  *[]Revision `json:"resources,omitempty"`
}

// Role A resource represents an individual object within the system, such as an app or a service. It is represented as a JSON object.
// A resource consists of several required resource fields and other attributes specific to the resource.
// See Resources and Experimental Resources for specific resources.
type Role = BaseSchema

// RoleCreateType Role type. Possible values are:
// - `organization_user`: A user in the organization
// - `organization_auditor`: An auditor in the organization
// - `organization_manager`: A manager in the organization
// - `organization_billing_manager`: A billing manager in the organization
// - `space_auditor`: An auditor in the space
// - `space_developer`: A developer in the space
// - `space_manager`: A manager in the space
// - `space_supporter`: A supporter in the space (not authorized to use the V2 API)
type RoleCreateType string

// Route defines model for route.
type Route struct {
	// CreatedAt The time the resource was created.
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Guid The GUID of the resource
	Guid *openapi_types.UUID `json:"guid,omitempty"`

	// Host The hostname for the route; can be null for TCP routes
	Host *string `json:"host,omitempty"`

	// Links Links provide URLs to relationships and actions for a resource. Links are represented as a JSON object and always contain a self link.
	Links *Links `json:"links,omitempty"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Path The path for the route; must start with a slash / and be less than 128 characters
	Path *string `json:"path,omitempty"`

	// Port The port for the route; can be null if not specified
	Port *int `json:"port,omitempty"`

	// Protocol Protocol used by the route; valid values are http1, http2, and tcp
	Protocol *string `json:"protocol,omitempty"`

	// Relationships Relationships represent associations between resources. When relationships are mutable, they can be used to create, read, update, and delete these associations. An app’s relationship to its current droplet is mutable, but an app’s relationship to its space is not.
	//
	// Relationships do not affect the fundamental properties of a resource, but may affect their behavior and permissions logic. Relationships are tied to the lifecycles of the associated resources and will be removed if either of the associated resources are deleted. For example, if a user is removed from an organization, both the user and the organization persist, but the relationship between them does not.
	//
	// Not all resources implement every relationship operation demonstrated in the examples below. See the docs for each resource to see how it interacts with its relationships.
	//
	// Endpoints that return relationship data list this information under the relationships key.
	//
	// The relationship object
	// The relationship object is a key-value pair that uniquely identifies a resource. In practice this is almost always the guid of a resource.
	Relationships *Relationships `json:"relationships,omitempty"`

	// UpdatedAt The time the resource was last updated
	// Timestamps generally appear in created_at and updated_at fields on resources.
	// Precision beyond seconds is not supported, even if the underlying database supports it (e.g. Postgres).
	// As a result, filtering on sub-second timestamps is not allowed.
	// All v3 timestamps have the following format YYYY-MM-DDThh:mm:ssZ.
	// Example timestamp (June 30, 2020 at 11:49:04 PM UTC): 2020-06-30T23:49:04Z
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Url Fully qualified path or address where the route directs traffic
	Url *string `json:"url,omitempty"`
}

// RouteDestination A route destination is a specification for where traffic on a route should be directed.
type RouteDestination struct {
	// App App to which the route destination directs traffic
	App *struct {
		// Guid GUID of the app
		Guid    *openapi_types.UUID `json:"guid,omitempty"`
		Process *struct {
			// Guid GUID of the process
			Guid *openapi_types.UUID `json:"guid,omitempty"`

			// Type Process type
			Type *string `json:"type,omitempty"`
		} `json:"process,omitempty"`
	} `json:"app,omitempty"`

	// CreatedAt The time with zone when the object was created
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Guid Unique identifier for the destination
	Guid *openapi_types.UUID `json:"guid,omitempty"`

	// Links Links provide URLs to relationships and actions for a resource. Links are represented as a JSON object and always contain a self link.
	Links *Links `json:"links,omitempty"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Port Port of the destination that receives traffic.
	Port *int `json:"port,omitempty"`

	// Protocol Valid protocols for route destinations
	Protocol *RouteDestinationsProtocol `json:"protocol,omitempty"`

	// UpdatedAt The time with zone when the object was last updated
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Weight Weight of the destination. Routes will equally distribute the traffic to all destinations with the same weight.
	Weight *int `json:"weight,omitempty"`
}

// RouteDestinationList A list of route destinations
type RouteDestinationList struct {
	Destinations *[]RouteDestination `json:"destinations,omitempty"`

	// Pagination Pagination is a technique used to divide a large set of results into smaller, more manageable sets. This allows clients to retrieve results in smaller chunks, reducing the amount of data transferred and improving performance.
	// The pagination object is a JSON object that contains information about the pagination state of the results. It includes the total number of results available, the total number of pages available, and links to the first, last, next, and previous pages of results.
	Pagination *Pagination `json:"pagination,omitempty"`
}

// RouteDestinationsProtocol Valid protocols for route destinations
type RouteDestinationsProtocol string

// User defines model for user.
type User struct {
	// CreatedAt The time with zone when the object was created
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Guid Unique identifier for the user
	Guid *string `json:"guid,omitempty"`

	// Links Links provide URLs to relationships and actions for a resource. Links are represented as a JSON object and always contain a self link.
	Links *Links `json:"links,omitempty"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Origin The origin of the user
	Origin *string `json:"origin,omitempty"`

	// PresentationName The presentation name of the user
	PresentationName *string `json:"presentation_name,omitempty"`

	// UpdatedAt The time with zone when the object was last updated
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Username The username of the user
	Username *string `json:"username,omitempty"`
}

// UserCreate defines model for userCreate.
type UserCreate struct {
	// CreatedAt The time with zone when the object was created
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Guid Unique identifier for the user
	Guid string `json:"guid"`

	// Links Links provide URLs to relationships and actions for a resource. Links are represented as a JSON object and always contain a self link.
	Links *Links `json:"links,omitempty"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Origin The origin of the user
	Origin *string `json:"origin,omitempty"`

	// PresentationName The presentation name of the user
	PresentationName *string `json:"presentation_name,omitempty"`

	// UpdatedAt The time with zone when the object was last updated
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Username The username of the user
	Username *string `json:"username,omitempty"`
}

// UserUpdate defines model for userUpdate.
type UserUpdate struct {
	// Links Links provide URLs to relationships and actions for a resource. Links are represented as a JSON object and always contain a self link.
	Links *Links `json:"links,omitempty"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Origin The origin of the user
	Origin *string `json:"origin,omitempty"`

	// PresentationName The presentation name of the user
	PresentationName *string `json:"presentation_name,omitempty"`

	// Username The username of the user
	Username *string `json:"username,omitempty"`
}

// Warning defines model for warning.
type Warning struct {
	// Detail Description of the warning
	Detail *string `json:"detail,omitempty"`
}

// CreatedAts defines model for createdAts.
type CreatedAts = string

// DropletGuid defines model for dropletGuid.
type DropletGuid = openapi_types.UUID

// EntityType defines model for entityType.
type EntityType = string

// Guid defines model for guid.
type Guid = openapi_types.UUID

// LabelSelector defines model for labelSelector.
type LabelSelector = string

// OrderBy defines model for orderBy.
type OrderBy = string

// Page defines model for page.
type Page = int

// PerPage defines model for perPage.
type PerPage = int

// UpdatedAts defines model for updatedAts.
type UpdatedAts = string

// RoleCreateResponse Roles represent a set of permissions that can be granted to users. Roles are represented as a JSON object.
// A role consists of several required role fields and other attributes specific to the role.
// See Roles for specific roles.
type RoleCreateResponse = Role

// RoleGetResponse Roles represent a set of permissions that can be granted to users. Roles are represented as a JSON object.
// A role consists of several required role fields and other attributes specific to the role.
// See Roles for specific roles.
type RoleGetResponse = Role

// RoleListResponse defines model for RoleListResponse.
type RoleListResponse struct {
	// Pagination Pagination is a technique used to divide a large set of results into smaller, more manageable sets. This allows clients to retrieve results in smaller chunks, reducing the amount of data transferred and improving performance.
	// The pagination object is a JSON object that contains information about the pagination state of the results. It includes the total number of results available, the total number of pages available, and links to the first, last, next, and previous pages of results.
	Pagination *Pagination `json:"pagination,omitempty"`
	Resources  *[]Role     `json:"resources,omitempty"`
}

// BuildpackCreateResponse A buildpack represents a set of scripts used to prepare an application for launch.
type BuildpackCreateResponse = Buildpack

// BuildpackGetResponse A buildpack represents a set of scripts used to prepare an application for launch.
type BuildpackGetResponse = Buildpack

// DropletCreateResponse A droplet is the result of staging an application package. There are two types (lifecycles) of droplets buildpack and docker. In the case of the buildpacks, the droplet contains the bits produced by the buildpack, typically application code and dependencies.
type DropletCreateResponse = Droplet

// DropletGetResponse A droplet is the result of staging an application package. There are two types (lifecycles) of droplets buildpack and docker. In the case of the buildpacks, the droplet contains the bits produced by the buildpack, typically application code and dependencies.
type DropletGetResponse = Droplet

// DropletListResponse defines model for dropletListResponse.
type DropletListResponse = DropletList

// RouteCreateResponse defines model for routeCreateResponse.
type RouteCreateResponse = Route

// RouteListResponse defines model for routeListResponse.
type RouteListResponse struct {
	// Pagination Pagination is a technique used to divide a large set of results into smaller, more manageable sets. This allows clients to retrieve results in smaller chunks, reducing the amount of data transferred and improving performance.
	// The pagination object is a JSON object that contains information about the pagination state of the results. It includes the total number of results available, the total number of pages available, and links to the first, last, next, and previous pages of results.
	Pagination *Pagination `json:"pagination,omitempty"`
	Resources  *[]Route    `json:"resources,omitempty"`
}

// UserCreateResponse defines model for userCreateResponse.
type UserCreateResponse = User

// UserUpdateResponse defines model for userUpdateResponse.
type UserUpdateResponse = User

// RoleCreate defines model for RoleCreate.
type RoleCreate struct {
	Relationships *struct {
		// Organization Some relationships relate a resource to exactly one other resource. For example an app can belong to only one space.
		Organization *RelationshipToOne `json:"organization,omitempty"`

		// Space Some relationships relate a resource to exactly one other resource. For example an app can belong to only one space.
		Space *RelationshipToOne `json:"space,omitempty"`

		// User Some relationships relate a resource to exactly one other resource. For example an app can belong to only one space.
		User *RelationshipToOne `json:"user,omitempty"`
	} `json:"relationships,omitempty"`

	// Type Role type
	Type *RoleCreateType `json:"type,omitempty"`
}

// BuildpackCreateRequestBody Request schema for creating a buildpack
type BuildpackCreateRequestBody struct {
	// Enabled Whether the buildpack is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// Filename The filename of the buildpack
	Filename *string `json:"filename,omitempty"`

	// Locked Whether the buildpack is locked
	Locked *bool `json:"locked,omitempty"`

	// Name The name of the buildpack
	Name string `json:"name"`

	// Position The position of the buildpack in the order of execution
	Position *int `json:"position,omitempty"`

	// Stack The stack the buildpack is compatible with
	Stack *string `json:"stack,omitempty"`

	// State Possible states of a buildpack
	State *BuildpackStateType `json:"state,omitempty"`
}

// DropletCreateRequestBody Request schema for creating a droplet
type DropletCreateRequestBody struct {
	// ProcessTypes Process names and start commands for the droplet
	ProcessTypes *map[string]interface{} `json:"process_types,omitempty"`

	// Relationships Relationships represent associations between resources. When relationships are mutable, they can be used to create, read, update, and delete these associations. An app’s relationship to its current droplet is mutable, but an app’s relationship to its space is not.
	//
	// Relationships do not affect the fundamental properties of a resource, but may affect their behavior and permissions logic. Relationships are tied to the lifecycles of the associated resources and will be removed if either of the associated resources are deleted. For example, if a user is removed from an organization, both the user and the organization persist, but the relationship between them does not.
	//
	// Not all resources implement every relationship operation demonstrated in the examples below. See the docs for each resource to see how it interacts with its relationships.
	//
	// Endpoints that return relationship data list this information under the relationships key.
	//
	// The relationship object
	// The relationship object is a key-value pair that uniquely identifies a resource. In practice this is almost always the guid of a resource.
	Relationships Relationships `json:"relationships"`
}

// IsolationSegmentCreate defines model for isolationSegmentCreate.
type IsolationSegmentCreate struct {
	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Name The name of the isolation segment
	Name string `json:"name"`
}

// PackageCreateRequestBody Request schema for creating a package
type PackageCreateRequestBody struct {
	// Data Data for package type
	Data *struct {
		// Image The registry address of the image (for docker type)
		Image *string `json:"image,omitempty"`

		// Password The password for the image's registry (for docker type)
		Password *string `json:"password,omitempty"`

		// Username The username for the image's registry (for docker type)
		Username *string `json:"username,omitempty"`
	} `json:"data,omitempty"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Relationships Relationships represent associations between resources. When relationships are mutable, they can be used to create, read, update, and delete these associations. An app’s relationship to its current droplet is mutable, but an app’s relationship to its space is not.
	//
	// Relationships do not affect the fundamental properties of a resource, but may affect their behavior and permissions logic. Relationships are tied to the lifecycles of the associated resources and will be removed if either of the associated resources are deleted. For example, if a user is removed from an organization, both the user and the organization persist, but the relationship between them does not.
	//
	// Not all resources implement every relationship operation demonstrated in the examples below. See the docs for each resource to see how it interacts with its relationships.
	//
	// Endpoints that return relationship data list this information under the relationships key.
	//
	// The relationship object
	// The relationship object is a key-value pair that uniquely identifies a resource. In practice this is almost always the guid of a resource.
	Relationships Relationships `json:"relationships"`

	// Type Valid package types
	Type PackageCreateRequestBodyType `json:"type"`
}

// PackageUpdateRequestBody Request schema for updating a package
type PackageUpdateRequestBody struct {
	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`
}

// RevisionUpdateRequestBody Request schema for updating a revision
type RevisionUpdateRequestBody struct {
	// Description Description of the revision
	Description *string `json:"description,omitempty"`

	// Enabled Whether the revision is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`
}

// RouteCreateRequestBody Request schema for creating a route
type RouteCreateRequestBody struct {
	// Host Hostname of the route; can be null for TCP routes
	Host *string `json:"host,omitempty"`

	// Path Path of the route; must start with a slash /.
	Path *string `json:"path,omitempty"`

	// Port Port of the route; can be null if not specified
	Port *int `json:"port,omitempty"`

	// Protocol Protocol used by the route; valid values are http1, http2, and tcp
	Protocol string `json:"protocol"`

	// Relationships Relationships represent associations between resources. When relationships are mutable, they can be used to create, read, update, and delete these associations. An app’s relationship to its current droplet is mutable, but an app’s relationship to its space is not.
	//
	// Relationships do not affect the fundamental properties of a resource, but may affect their behavior and permissions logic. Relationships are tied to the lifecycles of the associated resources and will be removed if either of the associated resources are deleted. For example, if a user is removed from an organization, both the user and the organization persist, but the relationship between them does not.
	//
	// Not all resources implement every relationship operation demonstrated in the examples below. See the docs for each resource to see how it interacts with its relationships.
	//
	// Endpoints that return relationship data list this information under the relationships key.
	//
	// The relationship object
	// The relationship object is a key-value pair that uniquely identifies a resource. In practice this is almost always the guid of a resource.
	Relationships Relationships `json:"relationships"`
}

// RouteDestinations List of route destinations
type RouteDestinations = []struct {
	// App App to which the route destination directs traffic. Must provide either app or service instance.
	App struct {
		// Guid App GUID
		Guid    *openapi_types.UUID `json:"guid,omitempty"`
		Process *struct {
			// Guid Process GUID
			Guid *openapi_types.UUID `json:"guid,omitempty"`

			// Type Process type
			Type *string `json:"type,omitempty"`
		} `json:"process,omitempty"`
	} `json:"app"`

	// Port Port of the destination that receives traffic.
	Port *int `json:"port,omitempty"`

	// Protocol Protocol of the destination that receives traffic. Defaults to 'http1' when not specified for HTTP routes, and is ignored for TCP routes.
	Protocol *RouteDestinationsProtocol `json:"protocol,omitempty"`

	// ServiceInstance Service instance to which the route destination directs traffic. Must provide either app or service instance.
	ServiceInstance *struct {
		// Guid Service Instance GUID
		Guid *openapi_types.UUID `json:"guid,omitempty"`
	} `json:"service_instance,omitempty"`

	// Weight Weight of the destination. Routes will equally distribute the traffic to all destinations with the same weight.
	Weight *int `json:"weight,omitempty"`
}

// ListAppUsageEventsParams defines parameters for ListAppUsageEvents.
type ListAppUsageEventsParams struct {
	// Page Page to display; valid values are integers >= 1
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of results per page, valid values are 1 through 5000
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// OrderBy Order results by a specific field. Prepend with - to sort descending.
	OrderBy *OrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// CreatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	CreatedAts *CreatedAts `form:"created_ats,omitempty" json:"created_ats,omitempty"`

	// AfterGuid Filters out events before and including the event with the given guid.
	AfterGuid *string `form:"after_guid,omitempty" json:"after_guid,omitempty"`

	// Guids Comma-delimited list of usage event guids to filter by.
	Guids *[]string `form:"guids,omitempty" json:"guids,omitempty"`
}

// ListAppsParams defines parameters for ListApps.
type ListAppsParams struct {
	// Page Page to display; valid values are integers >= 1
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of results per page, valid values are 1 through 5000
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// OrderBy Order results by a specific field. Prepend with - to sort descending.
	OrderBy *OrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// CreatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	CreatedAts *CreatedAts `form:"created_ats,omitempty" json:"created_ats,omitempty"`

	// UpdatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	UpdatedAts *UpdatedAts `form:"updated_ats,omitempty" json:"updated_ats,omitempty"`

	// LabelSelector Selectors allow users to filter and group API resources by the labels applied to them. A selector consists of one or more requirements in a comma-delimited list. The maximum number of requirements in a single selector is 50.
	//
	// Example label selector:
	// `cf curl /v3/apps?label_selector=env=dev,%21chargeback-code,tier%20in%20%28backend,worker%29`
	//
	// Selectors can be used to filter and group resources using the query parameter `label_selector` on list endpoints.
	//
	// When included in a URL, the selector must be appropriately escaped.
	//
	// A requirement consists of a key, an operator, and optional value(s).
	//
	// | Requirement    | Format                        | Description                                                                 |
	// |----------------|-------------------------------|-----------------------------------------------------------------------------|
	// | existence      | `key`                         | Returns all resources that have been assigned a label with the given key (with any value) |
	// | non-existence  | `!key`                        | Returns all resources that have not been assigned a label with the given key (with any value) |
	// | equality       | `key=value` or `key==value`   | Returns all resources that have been assigned a label with the given key and value |
	// | inequality     | `key!=value`                  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but a different value |
	// | set inclusion  | `key in (value1,value2…)`     | Returns all resources that have been assigned a label with the given key with one of the specified value(s) |
	// | set exclusion  | `key notin (value1,value2…)`  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but none of the specified value(s) |
	LabelSelector *LabelSelector `form:"label_selector,omitempty" json:"label_selector,omitempty"`

	// Guids Comma-delimited list of app GUIDs to filter by
	Guids *[]string `form:"guids,omitempty" json:"guids,omitempty"`

	// Names Comma-delimited list of app names to filter by
	Names *[]string `form:"names,omitempty" json:"names,omitempty"`

	// SpaceGuids Comma-delimited list of space GUIDs to filter by
	SpaceGuids *[]string `form:"space_guids,omitempty" json:"space_guids,omitempty"`

	// OrganizationGuids Comma-delimited list of organization GUIDs to filter by
	OrganizationGuids *[]string `form:"organization_guids,omitempty" json:"organization_guids,omitempty"`

	// Stacks Comma-delimited list of stack names to filter by
	Stacks *[]string `form:"stacks,omitempty" json:"stacks,omitempty"`
}

// CreateAppJSONBody defines parameters for CreateApp.
type CreateAppJSONBody struct {
	// Lifecycle The lifecycle type defines how the application droplet is created and run. The following lifecycle types are supported: - buildpack: Traditional buildpacks for Cloud Foundry applications. - cnb: Cloud Native Buildpacks that are OCI-compliant. - docker: Run pre-built Docker images.
	Lifecycle *Lifecycle `json:"lifecycle,omitempty"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Name The name of the app
	Name string `json:"name"`

	// Relationships Relationships represent associations between resources. When relationships are mutable, they can be used to create, read, update, and delete these associations. An app’s relationship to its current droplet is mutable, but an app’s relationship to its space is not.
	//
	// Relationships do not affect the fundamental properties of a resource, but may affect their behavior and permissions logic. Relationships are tied to the lifecycles of the associated resources and will be removed if either of the associated resources are deleted. For example, if a user is removed from an organization, both the user and the organization persist, but the relationship between them does not.
	//
	// Not all resources implement every relationship operation demonstrated in the examples below. See the docs for each resource to see how it interacts with its relationships.
	//
	// Endpoints that return relationship data list this information under the relationships key.
	//
	// The relationship object
	// The relationship object is a key-value pair that uniquely identifies a resource. In practice this is almost always the guid of a resource.
	Relationships Relationships `json:"relationships"`
}

// ListBuildsForAppParams defines parameters for ListBuildsForApp.
type ListBuildsForAppParams struct {
	// Page Page to display; valid values are integers >= 1
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of results per page, valid values are 1 through 5000
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// OrderBy Order results by a specific field. Prepend with - to sort descending.
	OrderBy *OrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// CreatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	CreatedAts *CreatedAts `form:"created_ats,omitempty" json:"created_ats,omitempty"`

	// UpdatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	UpdatedAts *UpdatedAts `form:"updated_ats,omitempty" json:"updated_ats,omitempty"`

	// LabelSelector Selectors allow users to filter and group API resources by the labels applied to them. A selector consists of one or more requirements in a comma-delimited list. The maximum number of requirements in a single selector is 50.
	//
	// Example label selector:
	// `cf curl /v3/apps?label_selector=env=dev,%21chargeback-code,tier%20in%20%28backend,worker%29`
	//
	// Selectors can be used to filter and group resources using the query parameter `label_selector` on list endpoints.
	//
	// When included in a URL, the selector must be appropriately escaped.
	//
	// A requirement consists of a key, an operator, and optional value(s).
	//
	// | Requirement    | Format                        | Description                                                                 |
	// |----------------|-------------------------------|-----------------------------------------------------------------------------|
	// | existence      | `key`                         | Returns all resources that have been assigned a label with the given key (with any value) |
	// | non-existence  | `!key`                        | Returns all resources that have not been assigned a label with the given key (with any value) |
	// | equality       | `key=value` or `key==value`   | Returns all resources that have been assigned a label with the given key and value |
	// | inequality     | `key!=value`                  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but a different value |
	// | set inclusion  | `key in (value1,value2…)`     | Returns all resources that have been assigned a label with the given key with one of the specified value(s) |
	// | set exclusion  | `key notin (value1,value2…)`  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but none of the specified value(s) |
	LabelSelector *LabelSelector `form:"label_selector,omitempty" json:"label_selector,omitempty"`

	// AppGuids Comma-delimited list of app GUIDs to filter by
	AppGuids *[]string `form:"app_guids,omitempty" json:"app_guids,omitempty"`

	// PackageGuids Comma-delimited list of package GUIDs to filter by
	PackageGuids *[]string `form:"package_guids,omitempty" json:"package_guids,omitempty"`
}

// UpdateAppJSONBody defines parameters for UpdateApp.
type UpdateAppJSONBody struct {
	// Lifecycle The lifecycle type defines how the application droplet is created and run. The following lifecycle types are supported: - buildpack: Traditional buildpacks for Cloud Foundry applications. - cnb: Cloud Native Buildpacks that are OCI-compliant. - docker: Run pre-built Docker images.
	Lifecycle *Lifecycle `json:"lifecycle,omitempty"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Name The name of the app
	Name string `json:"name"`
}

// SetCurrentDropletForAppJSONBody defines parameters for SetCurrentDropletForApp.
type SetCurrentDropletForAppJSONBody struct {
	Data Relationship `json:"data"`
}

// UpdateAppFeatureJSONBody defines parameters for UpdateAppFeature.
type UpdateAppFeatureJSONBody struct {
	// Enabled Whether the app feature should be enabled
	Enabled *bool `json:"enabled,omitempty"`
}

// ListPackagesForAppParams defines parameters for ListPackagesForApp.
type ListPackagesForAppParams struct {
	// Page Page to display; valid values are integers >= 1
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of results per page, valid values are 1 through 5000
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// OrderBy Order results by a specific field. Prepend with - to sort descending.
	OrderBy *OrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// CreatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	CreatedAts *CreatedAts `form:"created_ats,omitempty" json:"created_ats,omitempty"`

	// UpdatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	UpdatedAts *UpdatedAts `form:"updated_ats,omitempty" json:"updated_ats,omitempty"`

	// LabelSelector Selectors allow users to filter and group API resources by the labels applied to them. A selector consists of one or more requirements in a comma-delimited list. The maximum number of requirements in a single selector is 50.
	//
	// Example label selector:
	// `cf curl /v3/apps?label_selector=env=dev,%21chargeback-code,tier%20in%20%28backend,worker%29`
	//
	// Selectors can be used to filter and group resources using the query parameter `label_selector` on list endpoints.
	//
	// When included in a URL, the selector must be appropriately escaped.
	//
	// A requirement consists of a key, an operator, and optional value(s).
	//
	// | Requirement    | Format                        | Description                                                                 |
	// |----------------|-------------------------------|-----------------------------------------------------------------------------|
	// | existence      | `key`                         | Returns all resources that have been assigned a label with the given key (with any value) |
	// | non-existence  | `!key`                        | Returns all resources that have not been assigned a label with the given key (with any value) |
	// | equality       | `key=value` or `key==value`   | Returns all resources that have been assigned a label with the given key and value |
	// | inequality     | `key!=value`                  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but a different value |
	// | set inclusion  | `key in (value1,value2…)`     | Returns all resources that have been assigned a label with the given key with one of the specified value(s) |
	// | set exclusion  | `key notin (value1,value2…)`  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but none of the specified value(s) |
	LabelSelector *LabelSelector `form:"label_selector,omitempty" json:"label_selector,omitempty"`

	// Guids Comma-delimited list of package guids to filter by
	Guids *[]string `form:"guids,omitempty" json:"guids,omitempty"`

	// States Comma-delimited list of package states to filter by
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// Types Comma-delimited list of package types to filter by
	Types *[]string `form:"types,omitempty" json:"types,omitempty"`
}

// ListRevisionsForAppParams defines parameters for ListRevisionsForApp.
type ListRevisionsForAppParams struct {
	// Page Page to display; valid values are integers >= 1
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of results per page, valid values are 1 through 5000
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// OrderBy Order results by a specific field. Prepend with - to sort descending.
	OrderBy *OrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// CreatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	CreatedAts *CreatedAts `form:"created_ats,omitempty" json:"created_ats,omitempty"`

	// UpdatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	UpdatedAts *UpdatedAts `form:"updated_ats,omitempty" json:"updated_ats,omitempty"`

	// LabelSelector Selectors allow users to filter and group API resources by the labels applied to them. A selector consists of one or more requirements in a comma-delimited list. The maximum number of requirements in a single selector is 50.
	//
	// Example label selector:
	// `cf curl /v3/apps?label_selector=env=dev,%21chargeback-code,tier%20in%20%28backend,worker%29`
	//
	// Selectors can be used to filter and group resources using the query parameter `label_selector` on list endpoints.
	//
	// When included in a URL, the selector must be appropriately escaped.
	//
	// A requirement consists of a key, an operator, and optional value(s).
	//
	// | Requirement    | Format                        | Description                                                                 |
	// |----------------|-------------------------------|-----------------------------------------------------------------------------|
	// | existence      | `key`                         | Returns all resources that have been assigned a label with the given key (with any value) |
	// | non-existence  | `!key`                        | Returns all resources that have not been assigned a label with the given key (with any value) |
	// | equality       | `key=value` or `key==value`   | Returns all resources that have been assigned a label with the given key and value |
	// | inequality     | `key!=value`                  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but a different value |
	// | set inclusion  | `key in (value1,value2…)`     | Returns all resources that have been assigned a label with the given key with one of the specified value(s) |
	// | set exclusion  | `key notin (value1,value2…)`  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but none of the specified value(s) |
	LabelSelector *LabelSelector `form:"label_selector,omitempty" json:"label_selector,omitempty"`

	// Versions Filter by revision versions
	Versions *[]int `form:"versions,omitempty" json:"versions,omitempty"`
}

// ListDeployedRevisionsForAppParams defines parameters for ListDeployedRevisionsForApp.
type ListDeployedRevisionsForAppParams struct {
	// Page Page to display; valid values are integers >= 1
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of results per page, valid values are 1 through 5000
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// OrderBy Order results by a specific field. Prepend with - to sort descending.
	OrderBy *OrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// CreatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	CreatedAts *CreatedAts `form:"created_ats,omitempty" json:"created_ats,omitempty"`

	// UpdatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	UpdatedAts *UpdatedAts `form:"updated_ats,omitempty" json:"updated_ats,omitempty"`

	// LabelSelector Selectors allow users to filter and group API resources by the labels applied to them. A selector consists of one or more requirements in a comma-delimited list. The maximum number of requirements in a single selector is 50.
	//
	// Example label selector:
	// `cf curl /v3/apps?label_selector=env=dev,%21chargeback-code,tier%20in%20%28backend,worker%29`
	//
	// Selectors can be used to filter and group resources using the query parameter `label_selector` on list endpoints.
	//
	// When included in a URL, the selector must be appropriately escaped.
	//
	// A requirement consists of a key, an operator, and optional value(s).
	//
	// | Requirement    | Format                        | Description                                                                 |
	// |----------------|-------------------------------|-----------------------------------------------------------------------------|
	// | existence      | `key`                         | Returns all resources that have been assigned a label with the given key (with any value) |
	// | non-existence  | `!key`                        | Returns all resources that have not been assigned a label with the given key (with any value) |
	// | equality       | `key=value` or `key==value`   | Returns all resources that have been assigned a label with the given key and value |
	// | inequality     | `key!=value`                  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but a different value |
	// | set inclusion  | `key in (value1,value2…)`     | Returns all resources that have been assigned a label with the given key with one of the specified value(s) |
	// | set exclusion  | `key notin (value1,value2…)`  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but none of the specified value(s) |
	LabelSelector *LabelSelector `form:"label_selector,omitempty" json:"label_selector,omitempty"`

	// Versions Filter by revision versions
	Versions *[]int `form:"versions,omitempty" json:"versions,omitempty"`
}

// UpdateRevisionJSONBody defines parameters for UpdateRevision.
type UpdateRevisionJSONBody struct {
	// Description Description of the revision
	Description *string `json:"description,omitempty"`

	// Enabled Whether the revision is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`
}

// ListAuditEventsParams defines parameters for ListAuditEvents.
type ListAuditEventsParams struct {
	// Page Page to display; valid values are integers >= 1
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of results per page, valid values are 1 through 5000
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// OrderBy Order results by a specific field. Prepend with - to sort descending.
	OrderBy *OrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// CreatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	CreatedAts *CreatedAts `form:"created_ats,omitempty" json:"created_ats,omitempty"`

	// UpdatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	UpdatedAts *UpdatedAts `form:"updated_ats,omitempty" json:"updated_ats,omitempty"`

	// EntityType The type of the entity involved in the audit event. This can be used to filter audit events by the entity involved. For example, filtering by `type` can return audit events involving only apps, spaces, or organizations.
	EntityType *EntityType `form:"entity_type,omitempty" json:"entity_type,omitempty"`
	Type       *string     `form:"type,omitempty" json:"type,omitempty"`

	// TargetGuids Comma-delimited list of target GUIDs to filter by.
	TargetGuids *[]string `form:"target_guids,omitempty" json:"target_guids,omitempty"`

	// SpaceGuids Comma-delimited list of space GUIDs to filter by.
	SpaceGuids *[]string `form:"space_guids,omitempty" json:"space_guids,omitempty"`

	// OrganizationGuids Comma-delimited list of organization GUIDs to filter by.
	OrganizationGuids *[]string `form:"organization_guids,omitempty" json:"organization_guids,omitempty"`
}

// CreateAuditEventJSONBody defines parameters for CreateAuditEvent.
type CreateAuditEventJSONBody struct {
	Actor *struct {
		// Guid The unique identifier for the actor
		Guid *string `json:"guid,omitempty"`

		// Name The name of the actor
		Name *string `json:"name,omitempty"`

		// Type The actor type
		Type *string `json:"type,omitempty"`
	} `json:"actor,omitempty"`

	// Data Additional information about the event
	Data *map[string]interface{} `json:"data,omitempty"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata     *Metadata `json:"metadata,omitempty"`
	Organization *struct {
		// Guid The unique identifier for the organization
		Guid *string `json:"guid,omitempty"`
	} `json:"organization,omitempty"`
	Space *struct {
		// Guid The unique identifier for the space
		Guid *string `json:"guid,omitempty"`
	} `json:"space,omitempty"`
	Target *struct {
		// Guid The unique identifier for the target
		Guid *string `json:"guid,omitempty"`

		// Name The name of the target
		Name *string `json:"name,omitempty"`

		// Type The target type
		Type *string `json:"type,omitempty"`
	} `json:"target,omitempty"`

	// Type The type of the event
	Type *string `json:"type,omitempty"`
}

// ListBuildpacksParams defines parameters for ListBuildpacks.
type ListBuildpacksParams struct {
	// Page Page to display; valid values are integers >= 1
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of results per page, valid values are 1 through 5000
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// OrderBy Order results by a specific field. Prepend with - to sort descending.
	OrderBy *OrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// CreatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	CreatedAts *CreatedAts `form:"created_ats,omitempty" json:"created_ats,omitempty"`

	// UpdatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	UpdatedAts *UpdatedAts `form:"updated_ats,omitempty" json:"updated_ats,omitempty"`

	// LabelSelector Selectors allow users to filter and group API resources by the labels applied to them. A selector consists of one or more requirements in a comma-delimited list. The maximum number of requirements in a single selector is 50.
	//
	// Example label selector:
	// `cf curl /v3/apps?label_selector=env=dev,%21chargeback-code,tier%20in%20%28backend,worker%29`
	//
	// Selectors can be used to filter and group resources using the query parameter `label_selector` on list endpoints.
	//
	// When included in a URL, the selector must be appropriately escaped.
	//
	// A requirement consists of a key, an operator, and optional value(s).
	//
	// | Requirement    | Format                        | Description                                                                 |
	// |----------------|-------------------------------|-----------------------------------------------------------------------------|
	// | existence      | `key`                         | Returns all resources that have been assigned a label with the given key (with any value) |
	// | non-existence  | `!key`                        | Returns all resources that have not been assigned a label with the given key (with any value) |
	// | equality       | `key=value` or `key==value`   | Returns all resources that have been assigned a label with the given key and value |
	// | inequality     | `key!=value`                  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but a different value |
	// | set inclusion  | `key in (value1,value2…)`     | Returns all resources that have been assigned a label with the given key with one of the specified value(s) |
	// | set exclusion  | `key notin (value1,value2…)`  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but none of the specified value(s) |
	LabelSelector *LabelSelector `form:"label_selector,omitempty" json:"label_selector,omitempty"`

	// Name Comma-delimited list of buildpack names to filter by
	Name *[]string `form:"name,omitempty" json:"name,omitempty"`

	// Stacks Comma-delimited list of stacks to filter by
	Stacks *[]string `form:"stacks,omitempty" json:"stacks,omitempty"`
}

// CreateBuildpackJSONBody defines parameters for CreateBuildpack.
type CreateBuildpackJSONBody struct {
	// Enabled Whether the buildpack is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// Filename The filename of the buildpack
	Filename *string `json:"filename,omitempty"`

	// Locked Whether the buildpack is locked
	Locked *bool `json:"locked,omitempty"`

	// Name The name of the buildpack
	Name string `json:"name"`

	// Position The position of the buildpack in the order of execution
	Position *int `json:"position,omitempty"`

	// Stack The stack the buildpack is compatible with
	Stack *string `json:"stack,omitempty"`

	// State Possible states of a buildpack
	State *BuildpackStateType `json:"state,omitempty"`
}

// PpdateBuildpackJSONBody defines parameters for PpdateBuildpack.
type PpdateBuildpackJSONBody struct {
	// Enabled Whether the buildpack is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// Filename The filename of the buildpack
	Filename *string `json:"filename,omitempty"`

	// Locked Whether the buildpack is locked
	Locked *bool `json:"locked,omitempty"`

	// Name The name of the buildpack
	Name string `json:"name"`

	// Position The position of the buildpack in the order of execution
	Position *int `json:"position,omitempty"`

	// Stack The stack the buildpack is compatible with
	Stack *string `json:"stack,omitempty"`
}

// UploadBuildpackMultipartBody defines parameters for UploadBuildpack.
type UploadBuildpackMultipartBody struct {
	// Bits The buildpack file to be uploaded
	Bits openapi_types.File `json:"bits"`
}

// ListBuildsParams defines parameters for ListBuilds.
type ListBuildsParams struct {
	// Page Page to display; valid values are integers >= 1
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of results per page, valid values are 1 through 5000
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// OrderBy Order results by a specific field. Prepend with - to sort descending.
	OrderBy *OrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// CreatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	CreatedAts *CreatedAts `form:"created_ats,omitempty" json:"created_ats,omitempty"`

	// UpdatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	UpdatedAts *UpdatedAts `form:"updated_ats,omitempty" json:"updated_ats,omitempty"`

	// LabelSelector Selectors allow users to filter and group API resources by the labels applied to them. A selector consists of one or more requirements in a comma-delimited list. The maximum number of requirements in a single selector is 50.
	//
	// Example label selector:
	// `cf curl /v3/apps?label_selector=env=dev,%21chargeback-code,tier%20in%20%28backend,worker%29`
	//
	// Selectors can be used to filter and group resources using the query parameter `label_selector` on list endpoints.
	//
	// When included in a URL, the selector must be appropriately escaped.
	//
	// A requirement consists of a key, an operator, and optional value(s).
	//
	// | Requirement    | Format                        | Description                                                                 |
	// |----------------|-------------------------------|-----------------------------------------------------------------------------|
	// | existence      | `key`                         | Returns all resources that have been assigned a label with the given key (with any value) |
	// | non-existence  | `!key`                        | Returns all resources that have not been assigned a label with the given key (with any value) |
	// | equality       | `key=value` or `key==value`   | Returns all resources that have been assigned a label with the given key and value |
	// | inequality     | `key!=value`                  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but a different value |
	// | set inclusion  | `key in (value1,value2…)`     | Returns all resources that have been assigned a label with the given key with one of the specified value(s) |
	// | set exclusion  | `key notin (value1,value2…)`  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but none of the specified value(s) |
	LabelSelector *LabelSelector `form:"label_selector,omitempty" json:"label_selector,omitempty"`

	// AppGuids Comma-delimited list of app GUIDs to filter by
	AppGuids *[]string `form:"app_guids,omitempty" json:"app_guids,omitempty"`

	// PackageGuids Comma-delimited list of package GUIDs to filter by
	PackageGuids *[]string `form:"package_guids,omitempty" json:"package_guids,omitempty"`
}

// CreateBuildJSONBody defines parameters for CreateBuild.
type CreateBuildJSONBody struct {
	// Lifecycle The lifecycle type defines how the application droplet is created and run. The following lifecycle types are supported: - buildpack: Traditional buildpacks for Cloud Foundry applications. - cnb: Cloud Native Buildpacks that are OCI-compliant. - docker: Run pre-built Docker images.
	Lifecycle *Lifecycle `json:"lifecycle,omitempty"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata    `json:"metadata,omitempty"`
	Package  Relationship `json:"package"`

	// StagingDiskInMb Disk space in MB allocated for staging of the build
	StagingDiskInMb *int `json:"staging_disk_in_mb,omitempty"`

	// StagingLogRateLimitBytesPerSecond Log rate limit in bytes per second allocated for staging of the build
	StagingLogRateLimitBytesPerSecond *int `json:"staging_log_rate_limit_bytes_per_second,omitempty"`

	// StagingMemoryInMb Memory in MB allocated for staging of the build
	StagingMemoryInMb *int `json:"staging_memory_in_mb,omitempty"`
}

// UpdateBuildJSONBody defines parameters for UpdateBuild.
type UpdateBuildJSONBody struct {
	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`
}

// ListDeploymentsParams defines parameters for ListDeployments.
type ListDeploymentsParams struct {
	// Page Page to display; valid values are integers >= 1
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of results per page, valid values are 1 through 5000
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// OrderBy Order results by a specific field. Prepend with - to sort descending.
	OrderBy *OrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// CreatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	CreatedAts *CreatedAts `form:"created_ats,omitempty" json:"created_ats,omitempty"`

	// UpdatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	UpdatedAts *UpdatedAts `form:"updated_ats,omitempty" json:"updated_ats,omitempty"`

	// LabelSelector Selectors allow users to filter and group API resources by the labels applied to them. A selector consists of one or more requirements in a comma-delimited list. The maximum number of requirements in a single selector is 50.
	//
	// Example label selector:
	// `cf curl /v3/apps?label_selector=env=dev,%21chargeback-code,tier%20in%20%28backend,worker%29`
	//
	// Selectors can be used to filter and group resources using the query parameter `label_selector` on list endpoints.
	//
	// When included in a URL, the selector must be appropriately escaped.
	//
	// A requirement consists of a key, an operator, and optional value(s).
	//
	// | Requirement    | Format                        | Description                                                                 |
	// |----------------|-------------------------------|-----------------------------------------------------------------------------|
	// | existence      | `key`                         | Returns all resources that have been assigned a label with the given key (with any value) |
	// | non-existence  | `!key`                        | Returns all resources that have not been assigned a label with the given key (with any value) |
	// | equality       | `key=value` or `key==value`   | Returns all resources that have been assigned a label with the given key and value |
	// | inequality     | `key!=value`                  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but a different value |
	// | set inclusion  | `key in (value1,value2…)`     | Returns all resources that have been assigned a label with the given key with one of the specified value(s) |
	// | set exclusion  | `key notin (value1,value2…)`  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but none of the specified value(s) |
	LabelSelector *LabelSelector `form:"label_selector,omitempty" json:"label_selector,omitempty"`

	// AppGuids Comma-delimited list of app GUIDs to filter by
	AppGuids *[]string `form:"app_guids,omitempty" json:"app_guids,omitempty"`

	// States Comma-delimited list of deployment states to filter by
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// StatusReasons Comma-delimited list of status reasons to filter by; valid values include DEPLOYING, PAUSED, CANCELING, DEPLOYED, CANCELED, SUPERSEDED
	StatusReasons *[]string `form:"status_reasons,omitempty" json:"status_reasons,omitempty"`

	// StatusValues Comma-delimited list of status values to filter by; valid values include ACTIVE and FINALIZED
	StatusValues *[]string `form:"status_values,omitempty" json:"status_values,omitempty"`
}

// CreateDeploymentJSONBody defines parameters for CreateDeployment.
type CreateDeploymentJSONBody struct {
	Droplet *Relationship `json:"droplet,omitempty"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`
	Options  *struct {
		// MaxInFlight The maximum number of new instances to deploy simultaneously
		MaxInFlight *int `json:"max_in_flight,omitempty"`
	} `json:"options,omitempty"`

	// Relationships Relationships represent associations between resources. When relationships are mutable, they can be used to create, read, update, and delete these associations. An app’s relationship to its current droplet is mutable, but an app’s relationship to its space is not.
	//
	// Relationships do not affect the fundamental properties of a resource, but may affect their behavior and permissions logic. Relationships are tied to the lifecycles of the associated resources and will be removed if either of the associated resources are deleted. For example, if a user is removed from an organization, both the user and the organization persist, but the relationship between them does not.
	//
	// Not all resources implement every relationship operation demonstrated in the examples below. See the docs for each resource to see how it interacts with its relationships.
	//
	// Endpoints that return relationship data list this information under the relationships key.
	//
	// The relationship object
	// The relationship object is a key-value pair that uniquely identifies a resource. In practice this is almost always the guid of a resource.
	Relationships *Relationships `json:"relationships,omitempty"`
	Revision      *Relationship  `json:"revision,omitempty"`
	Strategy      *string        `json:"strategy,omitempty"`
}

// UpdateDeploymentJSONBody defines parameters for UpdateDeployment.
type UpdateDeploymentJSONBody struct {
	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`
}

// ListDomainsParams defines parameters for ListDomains.
type ListDomainsParams struct {
	// Page Page to display; valid values are integers >= 1
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of results per page, valid values are 1 through 5000
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// OrderBy Order results by a specific field. Prepend with - to sort descending.
	OrderBy *OrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// CreatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	CreatedAts *CreatedAts `form:"created_ats,omitempty" json:"created_ats,omitempty"`

	// UpdatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	UpdatedAts *UpdatedAts `form:"updated_ats,omitempty" json:"updated_ats,omitempty"`

	// LabelSelector Selectors allow users to filter and group API resources by the labels applied to them. A selector consists of one or more requirements in a comma-delimited list. The maximum number of requirements in a single selector is 50.
	//
	// Example label selector:
	// `cf curl /v3/apps?label_selector=env=dev,%21chargeback-code,tier%20in%20%28backend,worker%29`
	//
	// Selectors can be used to filter and group resources using the query parameter `label_selector` on list endpoints.
	//
	// When included in a URL, the selector must be appropriately escaped.
	//
	// A requirement consists of a key, an operator, and optional value(s).
	//
	// | Requirement    | Format                        | Description                                                                 |
	// |----------------|-------------------------------|-----------------------------------------------------------------------------|
	// | existence      | `key`                         | Returns all resources that have been assigned a label with the given key (with any value) |
	// | non-existence  | `!key`                        | Returns all resources that have not been assigned a label with the given key (with any value) |
	// | equality       | `key=value` or `key==value`   | Returns all resources that have been assigned a label with the given key and value |
	// | inequality     | `key!=value`                  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but a different value |
	// | set inclusion  | `key in (value1,value2…)`     | Returns all resources that have been assigned a label with the given key with one of the specified value(s) |
	// | set exclusion  | `key notin (value1,value2…)`  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but none of the specified value(s) |
	LabelSelector *LabelSelector `form:"label_selector,omitempty" json:"label_selector,omitempty"`

	// Guids Comma-delimited list of GUIDs to filter by
	Guids *[]string `form:"guids,omitempty" json:"guids,omitempty"`

	// Names Comma-delimited list of domain names to filter by
	Names *[]string `form:"names,omitempty" json:"names,omitempty"`

	// OrganizationGuids Comma-delimited list of owning organization GUIDs to filter by
	OrganizationGuids *[]string `form:"organization_guids,omitempty" json:"organization_guids,omitempty"`
}

// CreateDomainJSONBody defines parameters for CreateDomain.
type CreateDomainJSONBody struct {
	// Internal Whether the domain is used for internal (container-to-container) traffic
	Internal bool `json:"internal"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Name The name of the domain
	Name string `json:"name"`

	// Organization Some relationships relate a resource to exactly one other resource. For example an app can belong to only one space.
	Organization *RelationshipToOne `json:"organization,omitempty"`
	RouterGroup  *struct {
		// Guid The desired router group GUID
		Guid *openapi_types.UUID `json:"guid,omitempty"`
	} `json:"router_group,omitempty"`

	// SharedOrganizations Some relationships relate a resource to several other resources. For example, an isolation segment can be entitled to multiple organizations.
	SharedOrganizations *RelationshipToMany `json:"shared_organizations,omitempty"`
}

// UpdateDomainJSONBody defines parameters for UpdateDomain.
type UpdateDomainJSONBody struct {
	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`
}

// ShareDomainJSONBody defines parameters for ShareDomain.
type ShareDomainJSONBody struct {
	Data *[]Relationship `json:"data,omitempty"`
}

// ListDropletsParams defines parameters for ListDroplets.
type ListDropletsParams struct {
	// Page Page to display; valid values are integers >= 1
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of results per page, valid values are 1 through 5000
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// OrderBy Order results by a specific field. Prepend with - to sort descending.
	OrderBy *OrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// CreatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	CreatedAts *CreatedAts `form:"created_ats,omitempty" json:"created_ats,omitempty"`

	// UpdatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	UpdatedAts *UpdatedAts `form:"updated_ats,omitempty" json:"updated_ats,omitempty"`

	// LabelSelector Selectors allow users to filter and group API resources by the labels applied to them. A selector consists of one or more requirements in a comma-delimited list. The maximum number of requirements in a single selector is 50.
	//
	// Example label selector:
	// `cf curl /v3/apps?label_selector=env=dev,%21chargeback-code,tier%20in%20%28backend,worker%29`
	//
	// Selectors can be used to filter and group resources using the query parameter `label_selector` on list endpoints.
	//
	// When included in a URL, the selector must be appropriately escaped.
	//
	// A requirement consists of a key, an operator, and optional value(s).
	//
	// | Requirement    | Format                        | Description                                                                 |
	// |----------------|-------------------------------|-----------------------------------------------------------------------------|
	// | existence      | `key`                         | Returns all resources that have been assigned a label with the given key (with any value) |
	// | non-existence  | `!key`                        | Returns all resources that have not been assigned a label with the given key (with any value) |
	// | equality       | `key=value` or `key==value`   | Returns all resources that have been assigned a label with the given key and value |
	// | inequality     | `key!=value`                  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but a different value |
	// | set inclusion  | `key in (value1,value2…)`     | Returns all resources that have been assigned a label with the given key with one of the specified value(s) |
	// | set exclusion  | `key notin (value1,value2…)`  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but none of the specified value(s) |
	LabelSelector *LabelSelector `form:"label_selector,omitempty" json:"label_selector,omitempty"`

	// Guids Comma-delimited list of droplet GUIDs to filter by
	Guids *[]string `form:"guids,omitempty" json:"guids,omitempty"`

	// States Comma-delimited list of droplet states to filter by
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// AppGuids Comma-delimited list of app GUIDs to filter by
	AppGuids *[]string `form:"app_guids,omitempty" json:"app_guids,omitempty"`

	// SpaceGuids Comma-delimited list of space GUIDs to filter by
	SpaceGuids *[]string `form:"space_guids,omitempty" json:"space_guids,omitempty"`

	// OrganizationGuids Comma-delimited list of organization GUIDs to filter by
	OrganizationGuids *[]string `form:"organization_guids,omitempty" json:"organization_guids,omitempty"`
}

// CreateDropletJSONBody defines parameters for CreateDroplet.
type CreateDropletJSONBody struct {
	// ProcessTypes Process names and start commands for the droplet
	ProcessTypes *map[string]interface{} `json:"process_types,omitempty"`

	// Relationships Relationships represent associations between resources. When relationships are mutable, they can be used to create, read, update, and delete these associations. An app’s relationship to its current droplet is mutable, but an app’s relationship to its space is not.
	//
	// Relationships do not affect the fundamental properties of a resource, but may affect their behavior and permissions logic. Relationships are tied to the lifecycles of the associated resources and will be removed if either of the associated resources are deleted. For example, if a user is removed from an organization, both the user and the organization persist, but the relationship between them does not.
	//
	// Not all resources implement every relationship operation demonstrated in the examples below. See the docs for each resource to see how it interacts with its relationships.
	//
	// Endpoints that return relationship data list this information under the relationships key.
	//
	// The relationship object
	// The relationship object is a key-value pair that uniquely identifies a resource. In practice this is almost always the guid of a resource.
	Relationships Relationships `json:"relationships"`
}

// UpdateDropletJSONBody defines parameters for UpdateDroplet.
type UpdateDropletJSONBody struct {
	// Image Image reference where the built complete image was stored
	Image string `json:"image"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`
}

// UploadDropletMultipartBody defines parameters for UploadDroplet.
type UploadDropletMultipartBody struct {
	// Bits The droplet file to be uploaded
	Bits openapi_types.File `json:"bits"`
}

// UpdateRunningEnvironmentVariableGroupJSONBody defines parameters for UpdateRunningEnvironmentVariableGroup.
type UpdateRunningEnvironmentVariableGroupJSONBody struct {
	// Var Environment variables to inject; keys and values must be strings
	Var *map[string]string `json:"var,omitempty"`
}

// UpdateStagingEnvironmentVariableGroupJSONBody defines parameters for UpdateStagingEnvironmentVariableGroup.
type UpdateStagingEnvironmentVariableGroupJSONBody struct {
	// Var Environment variables to inject; keys and values must be strings
	Var *map[string]string `json:"var,omitempty"`
}

// ListFeatureFlagsParams defines parameters for ListFeatureFlags.
type ListFeatureFlagsParams struct {
	// Page Page to display; valid values are integers >= 1
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of results per page, valid values are 1 through 5000
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// OrderBy Order results by a specific field. Prepend with - to sort descending.
	OrderBy *OrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// UpdatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	UpdatedAts *string `form:"updated_ats,omitempty" json:"updated_ats,omitempty"`
}

// CreateFeatureFlagJSONBody defines parameters for CreateFeatureFlag.
type CreateFeatureFlagJSONBody struct {
	// CustomErrorMessage The error string returned by the API when a client performs an action disabled by the feature flag
	CustomErrorMessage *string `json:"custom_error_message,omitempty"`

	// Enabled Whether the feature flag is enabled
	Enabled bool `json:"enabled"`

	// Name The name of the feature flag
	Name string `json:"name"`
}

// UpdateFeatureFlagJSONBody defines parameters for UpdateFeatureFlag.
type UpdateFeatureFlagJSONBody struct {
	// CustomErrorMessage The error string returned by the API when a client performs an action disabled by the feature flag
	CustomErrorMessage *string `json:"custom_error_message,omitempty"`

	// Enabled Whether the feature flag is enabled
	Enabled *bool `json:"enabled,omitempty"`
}

// ListIsolationSegmentsParams defines parameters for ListIsolationSegments.
type ListIsolationSegmentsParams struct {
	// Page Page to display; valid values are integers >= 1
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of results per page, valid values are 1 through 5000
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// OrderBy Order results by a specific field. Prepend with - to sort descending.
	OrderBy *OrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// CreatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	CreatedAts *CreatedAts `form:"created_ats,omitempty" json:"created_ats,omitempty"`

	// UpdatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	UpdatedAts *UpdatedAts `form:"updated_ats,omitempty" json:"updated_ats,omitempty"`

	// LabelSelector Selectors allow users to filter and group API resources by the labels applied to them. A selector consists of one or more requirements in a comma-delimited list. The maximum number of requirements in a single selector is 50.
	//
	// Example label selector:
	// `cf curl /v3/apps?label_selector=env=dev,%21chargeback-code,tier%20in%20%28backend,worker%29`
	//
	// Selectors can be used to filter and group resources using the query parameter `label_selector` on list endpoints.
	//
	// When included in a URL, the selector must be appropriately escaped.
	//
	// A requirement consists of a key, an operator, and optional value(s).
	//
	// | Requirement    | Format                        | Description                                                                 |
	// |----------------|-------------------------------|-----------------------------------------------------------------------------|
	// | existence      | `key`                         | Returns all resources that have been assigned a label with the given key (with any value) |
	// | non-existence  | `!key`                        | Returns all resources that have not been assigned a label with the given key (with any value) |
	// | equality       | `key=value` or `key==value`   | Returns all resources that have been assigned a label with the given key and value |
	// | inequality     | `key!=value`                  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but a different value |
	// | set inclusion  | `key in (value1,value2…)`     | Returns all resources that have been assigned a label with the given key with one of the specified value(s) |
	// | set exclusion  | `key notin (value1,value2…)`  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but none of the specified value(s) |
	LabelSelector *LabelSelector `form:"label_selector,omitempty" json:"label_selector,omitempty"`

	// Guids Comma-delimited list of isolation segment guids to filter by.
	Guids *[]string `form:"guids,omitempty" json:"guids,omitempty"`

	// Names Comma-delimited list of isolation segment names to filter by.
	Names *[]string `form:"names,omitempty" json:"names,omitempty"`

	// OrganizationGuids Comma-delimited list of organization guids to filter by.
	OrganizationGuids *[]string `form:"organization_guids,omitempty" json:"organization_guids,omitempty"`
}

// CreateIsolationSegmentJSONBody defines parameters for CreateIsolationSegment.
type CreateIsolationSegmentJSONBody struct {
	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Name The name of the isolation segment
	Name string `json:"name"`
}

// UpdateIsolationSegmentJSONBody defines parameters for UpdateIsolationSegment.
type UpdateIsolationSegmentJSONBody struct {
	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Name The name of the isolation segment
	Name *string `json:"name,omitempty"`
}

// ListOrganizationsForIsolationSegmentParams defines parameters for ListOrganizationsForIsolationSegment.
type ListOrganizationsForIsolationSegmentParams struct {
	// Page Page to display; valid values are integers >= 1
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of results per page, valid values are 1 through 5000
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`
}

// ListSpacesForIsolationSegmentParams defines parameters for ListSpacesForIsolationSegment.
type ListSpacesForIsolationSegmentParams struct {
	// Page Page to display; valid values are integers >= 1
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of results per page, valid values are 1 through 5000
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`
}

// ListJobsParams defines parameters for ListJobs.
type ListJobsParams struct {
	// Page Page to display; valid values are integers >= 1
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of results per page, valid values are 1 through 5000
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// OrderBy Order results by a specific field. Prepend with - to sort descending.
	OrderBy *OrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// CreatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	CreatedAts *CreatedAts `form:"created_ats,omitempty" json:"created_ats,omitempty"`

	// UpdatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	UpdatedAts *UpdatedAts `form:"updated_ats,omitempty" json:"updated_ats,omitempty"`

	// LabelSelector Selectors allow users to filter and group API resources by the labels applied to them. A selector consists of one or more requirements in a comma-delimited list. The maximum number of requirements in a single selector is 50.
	//
	// Example label selector:
	// `cf curl /v3/apps?label_selector=env=dev,%21chargeback-code,tier%20in%20%28backend,worker%29`
	//
	// Selectors can be used to filter and group resources using the query parameter `label_selector` on list endpoints.
	//
	// When included in a URL, the selector must be appropriately escaped.
	//
	// A requirement consists of a key, an operator, and optional value(s).
	//
	// | Requirement    | Format                        | Description                                                                 |
	// |----------------|-------------------------------|-----------------------------------------------------------------------------|
	// | existence      | `key`                         | Returns all resources that have been assigned a label with the given key (with any value) |
	// | non-existence  | `!key`                        | Returns all resources that have not been assigned a label with the given key (with any value) |
	// | equality       | `key=value` or `key==value`   | Returns all resources that have been assigned a label with the given key and value |
	// | inequality     | `key!=value`                  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but a different value |
	// | set inclusion  | `key in (value1,value2…)`     | Returns all resources that have been assigned a label with the given key with one of the specified value(s) |
	// | set exclusion  | `key notin (value1,value2…)`  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but none of the specified value(s) |
	LabelSelector *LabelSelector `form:"label_selector,omitempty" json:"label_selector,omitempty"`

	// Guids Comma-delimited list of job guids to filter by
	Guids *[]string `form:"guids,omitempty" json:"guids,omitempty"`

	// States Comma-delimited list of job states to filter by
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// Operations Comma-delimited list of operation types to filter by
	Operations *[]string `form:"operations,omitempty" json:"operations,omitempty"`

	// ResourceGuids Comma-delimited list of resource guids to filter by
	ResourceGuids *[]string `form:"resource_guids,omitempty" json:"resource_guids,omitempty"`
}

// ListDomainsForOrganizationParams defines parameters for ListDomainsForOrganization.
type ListDomainsForOrganizationParams struct {
	// Page Page to display; valid values are integers >= 1
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of results per page, valid values are 1 through 5000
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// OrderBy Order results by a specific field. Prepend with - to sort descending.
	OrderBy *OrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// CreatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	CreatedAts *CreatedAts `form:"created_ats,omitempty" json:"created_ats,omitempty"`

	// UpdatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	UpdatedAts *UpdatedAts `form:"updated_ats,omitempty" json:"updated_ats,omitempty"`

	// Guids Comma-delimited list of GUIDs to filter by
	Guids *[]string `form:"guids,omitempty" json:"guids,omitempty"`

	// Names Comma-delimited list of domain names to filter by
	Names *[]string `form:"names,omitempty" json:"names,omitempty"`
}

// ListPackagesParams defines parameters for ListPackages.
type ListPackagesParams struct {
	// Page Page to display; valid values are integers >= 1
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of results per page, valid values are 1 through 5000
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// OrderBy Order results by a specific field. Prepend with - to sort descending.
	OrderBy *OrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// CreatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	CreatedAts *CreatedAts `form:"created_ats,omitempty" json:"created_ats,omitempty"`

	// UpdatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	UpdatedAts *UpdatedAts `form:"updated_ats,omitempty" json:"updated_ats,omitempty"`

	// LabelSelector Selectors allow users to filter and group API resources by the labels applied to them. A selector consists of one or more requirements in a comma-delimited list. The maximum number of requirements in a single selector is 50.
	//
	// Example label selector:
	// `cf curl /v3/apps?label_selector=env=dev,%21chargeback-code,tier%20in%20%28backend,worker%29`
	//
	// Selectors can be used to filter and group resources using the query parameter `label_selector` on list endpoints.
	//
	// When included in a URL, the selector must be appropriately escaped.
	//
	// A requirement consists of a key, an operator, and optional value(s).
	//
	// | Requirement    | Format                        | Description                                                                 |
	// |----------------|-------------------------------|-----------------------------------------------------------------------------|
	// | existence      | `key`                         | Returns all resources that have been assigned a label with the given key (with any value) |
	// | non-existence  | `!key`                        | Returns all resources that have not been assigned a label with the given key (with any value) |
	// | equality       | `key=value` or `key==value`   | Returns all resources that have been assigned a label with the given key and value |
	// | inequality     | `key!=value`                  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but a different value |
	// | set inclusion  | `key in (value1,value2…)`     | Returns all resources that have been assigned a label with the given key with one of the specified value(s) |
	// | set exclusion  | `key notin (value1,value2…)`  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but none of the specified value(s) |
	LabelSelector *LabelSelector `form:"label_selector,omitempty" json:"label_selector,omitempty"`

	// Guids Comma-delimited list of package guids to filter by
	Guids *[]string `form:"guids,omitempty" json:"guids,omitempty"`

	// States Comma-delimited list of package states to filter by
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// Types Comma-delimited list of package types to filter by
	Types *[]string `form:"types,omitempty" json:"types,omitempty"`

	// AppGuids Comma-delimited list of app guids to filter by
	AppGuids *[]string `form:"app_guids,omitempty" json:"app_guids,omitempty"`

	// SpaceGuids Comma-delimited list of space guids to filter by
	SpaceGuids *[]string `form:"space_guids,omitempty" json:"space_guids,omitempty"`

	// OrganizationGuids Comma-delimited list of organization guids to filter by
	OrganizationGuids *[]string `form:"organization_guids,omitempty" json:"organization_guids,omitempty"`
}

// CreatePackageJSONBody defines parameters for CreatePackage.
type CreatePackageJSONBody struct {
	// Data Data for package type
	Data *struct {
		// Image The registry address of the image (for docker type)
		Image *string `json:"image,omitempty"`

		// Password The password for the image's registry (for docker type)
		Password *string `json:"password,omitempty"`

		// Username The username for the image's registry (for docker type)
		Username *string `json:"username,omitempty"`
	} `json:"data,omitempty"`

	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Relationships Relationships represent associations between resources. When relationships are mutable, they can be used to create, read, update, and delete these associations. An app’s relationship to its current droplet is mutable, but an app’s relationship to its space is not.
	//
	// Relationships do not affect the fundamental properties of a resource, but may affect their behavior and permissions logic. Relationships are tied to the lifecycles of the associated resources and will be removed if either of the associated resources are deleted. For example, if a user is removed from an organization, both the user and the organization persist, but the relationship between them does not.
	//
	// Not all resources implement every relationship operation demonstrated in the examples below. See the docs for each resource to see how it interacts with its relationships.
	//
	// Endpoints that return relationship data list this information under the relationships key.
	//
	// The relationship object
	// The relationship object is a key-value pair that uniquely identifies a resource. In practice this is almost always the guid of a resource.
	Relationships Relationships `json:"relationships"`

	// Type Valid package types
	Type PackageCreateRequestBodyType `json:"type"`
}

// UpdatePackageJSONBody defines parameters for UpdatePackage.
type UpdatePackageJSONBody struct {
	// Metadata Metadata is a JSON object that contains information about a resource. It includes the GUID of the resource, the time the resource was created, the time the resource was last updated, and links to the resource.
	// Metadata is included in the response body of a request to retrieve a resource.
	Metadata *Metadata `json:"metadata,omitempty"`
}

// UploadPackageBitsMultipartBody defines parameters for UploadPackageBits.
type UploadPackageBitsMultipartBody struct {
	// Bits A binary zip file containing the package bits
	Bits      openapi_types.File        `json:"bits"`
	Resources *[]map[string]interface{} `json:"resources,omitempty"`
}

// ListRolesParams defines parameters for ListRoles.
type ListRolesParams struct {
	// Page Page to display; valid values are integers >= 1
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of results per page, valid values are 1 through 5000
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// OrderBy Order results by a specific field. Prepend with - to sort descending.
	OrderBy *OrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// CreatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	CreatedAts *CreatedAts `form:"created_ats,omitempty" json:"created_ats,omitempty"`

	// UpdatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	UpdatedAts *UpdatedAts `form:"updated_ats,omitempty" json:"updated_ats,omitempty"`

	// LabelSelector Selectors allow users to filter and group API resources by the labels applied to them. A selector consists of one or more requirements in a comma-delimited list. The maximum number of requirements in a single selector is 50.
	//
	// Example label selector:
	// `cf curl /v3/apps?label_selector=env=dev,%21chargeback-code,tier%20in%20%28backend,worker%29`
	//
	// Selectors can be used to filter and group resources using the query parameter `label_selector` on list endpoints.
	//
	// When included in a URL, the selector must be appropriately escaped.
	//
	// A requirement consists of a key, an operator, and optional value(s).
	//
	// | Requirement    | Format                        | Description                                                                 |
	// |----------------|-------------------------------|-----------------------------------------------------------------------------|
	// | existence      | `key`                         | Returns all resources that have been assigned a label with the given key (with any value) |
	// | non-existence  | `!key`                        | Returns all resources that have not been assigned a label with the given key (with any value) |
	// | equality       | `key=value` or `key==value`   | Returns all resources that have been assigned a label with the given key and value |
	// | inequality     | `key!=value`                  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but a different value |
	// | set inclusion  | `key in (value1,value2…)`     | Returns all resources that have been assigned a label with the given key with one of the specified value(s) |
	// | set exclusion  | `key notin (value1,value2…)`  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but none of the specified value(s) |
	LabelSelector *LabelSelector `form:"label_selector,omitempty" json:"label_selector,omitempty"`

	// Guids Comma-delimited list of role guids to filter by
	Guids *[]string `form:"guids,omitempty" json:"guids,omitempty"`

	// Types Comma-delimited list of role types to filter by
	Types *[]ListRolesParamsTypes `form:"types,omitempty" json:"types,omitempty"`

	// OrganizationGuids Comma-delimited list of organization guids to filter by
	OrganizationGuids *[]string `form:"organization_guids,omitempty" json:"organization_guids,omitempty"`

	// SpaceGuids Comma-delimited list of space guids to filter by
	SpaceGuids *[]string `form:"space_guids,omitempty" json:"space_guids,omitempty"`

	// UserGuids Comma-delimited list of user guids to filter by
	UserGuids *[]string `form:"user_guids,omitempty" json:"user_guids,omitempty"`

	// Include Optionally include additional related resources in the response; valid values are `user`, `space`, and `organization`.
	Include *[]ListRolesParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// ListRolesParamsTypes defines parameters for ListRoles.
type ListRolesParamsTypes string

// ListRolesParamsInclude defines parameters for ListRoles.
type ListRolesParamsInclude string

// CreateRoleJSONBody defines parameters for CreateRole.
type CreateRoleJSONBody struct {
	Relationships *struct {
		// Organization Some relationships relate a resource to exactly one other resource. For example an app can belong to only one space.
		Organization *RelationshipToOne `json:"organization,omitempty"`

		// Space Some relationships relate a resource to exactly one other resource. For example an app can belong to only one space.
		Space *RelationshipToOne `json:"space,omitempty"`

		// User Some relationships relate a resource to exactly one other resource. For example an app can belong to only one space.
		User *RelationshipToOne `json:"user,omitempty"`
	} `json:"relationships,omitempty"`

	// Type Role type
	Type *CreateRoleJSONBodyType `json:"type,omitempty"`
}

// CreateRoleJSONBodyType defines parameters for CreateRole.
type CreateRoleJSONBodyType string

// GetRoleParams defines parameters for GetRole.
type GetRoleParams struct {
	// Include Optionally include additional related resources in the response; valid values are `user`, `space`, and `organization`.
	Include *[]GetRoleParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// GetRoleParamsInclude defines parameters for GetRole.
type GetRoleParamsInclude string

// ListRoutesParams defines parameters for ListRoutes.
type ListRoutesParams struct {
	// Page Page to display; valid values are integers >= 1
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of results per page, valid values are 1 through 5000
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// OrderBy Order results by a specific field. Prepend with - to sort descending.
	OrderBy *OrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// CreatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	CreatedAts *CreatedAts `form:"created_ats,omitempty" json:"created_ats,omitempty"`

	// UpdatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	UpdatedAts *UpdatedAts `form:"updated_ats,omitempty" json:"updated_ats,omitempty"`

	// LabelSelector Selectors allow users to filter and group API resources by the labels applied to them. A selector consists of one or more requirements in a comma-delimited list. The maximum number of requirements in a single selector is 50.
	//
	// Example label selector:
	// `cf curl /v3/apps?label_selector=env=dev,%21chargeback-code,tier%20in%20%28backend,worker%29`
	//
	// Selectors can be used to filter and group resources using the query parameter `label_selector` on list endpoints.
	//
	// When included in a URL, the selector must be appropriately escaped.
	//
	// A requirement consists of a key, an operator, and optional value(s).
	//
	// | Requirement    | Format                        | Description                                                                 |
	// |----------------|-------------------------------|-----------------------------------------------------------------------------|
	// | existence      | `key`                         | Returns all resources that have been assigned a label with the given key (with any value) |
	// | non-existence  | `!key`                        | Returns all resources that have not been assigned a label with the given key (with any value) |
	// | equality       | `key=value` or `key==value`   | Returns all resources that have been assigned a label with the given key and value |
	// | inequality     | `key!=value`                  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but a different value |
	// | set inclusion  | `key in (value1,value2…)`     | Returns all resources that have been assigned a label with the given key with one of the specified value(s) |
	// | set exclusion  | `key notin (value1,value2…)`  | Returns all resources that either have not been assigned a label with the given key or have a label with the given key but none of the specified value(s) |
	LabelSelector *LabelSelector `form:"label_selector,omitempty" json:"label_selector,omitempty"`

	// Protocols Comma-delimited list of protocols to filter by
	Protocols *[]string `form:"protocols,omitempty" json:"protocols,omitempty"`

	// Hosts Comma-delimited list of hosts to filter by
	Hosts *[]string `form:"hosts,omitempty" json:"hosts,omitempty"`

	// Paths Comma-delimited list of paths to filter by
	Paths *[]string `form:"paths,omitempty" json:"paths,omitempty"`

	// Ports Comma-delimited list of ports to filter by
	Ports *[]int `form:"ports,omitempty" json:"ports,omitempty"`

	// DomainGuids Comma-delimited list of domain GUIDs to filter by
	DomainGuids *[]string `form:"domain_guids,omitempty" json:"domain_guids,omitempty"`

	// SpaceGuids Comma-delimited list of space GUIDs to filter by
	SpaceGuids *[]string `form:"space_guids,omitempty" json:"space_guids,omitempty"`
}

// CreateRouteJSONBody defines parameters for CreateRoute.
type CreateRouteJSONBody struct {
	// Host Hostname of the route; can be null for TCP routes
	Host *string `json:"host,omitempty"`

	// Path Path of the route; must start with a slash /.
	Path *string `json:"path,omitempty"`

	// Port Port of the route; can be null if not specified
	Port *int `json:"port,omitempty"`

	// Protocol Protocol used by the route; valid values are http1, http2, and tcp
	Protocol string `json:"protocol"`

	// Relationships Relationships represent associations between resources. When relationships are mutable, they can be used to create, read, update, and delete these associations. An app’s relationship to its current droplet is mutable, but an app’s relationship to its space is not.
	//
	// Relationships do not affect the fundamental properties of a resource, but may affect their behavior and permissions logic. Relationships are tied to the lifecycles of the associated resources and will be removed if either of the associated resources are deleted. For example, if a user is removed from an organization, both the user and the organization persist, but the relationship between them does not.
	//
	// Not all resources implement every relationship operation demonstrated in the examples below. See the docs for each resource to see how it interacts with its relationships.
	//
	// Endpoints that return relationship data list this information under the relationships key.
	//
	// The relationship object
	// The relationship object is a key-value pair that uniquely identifies a resource. In practice this is almost always the guid of a resource.
	Relationships Relationships `json:"relationships"`
}

// ListDestinationsForRouteParams defines parameters for ListDestinationsForRoute.
type ListDestinationsForRouteParams struct {
	// Page Page to display; valid values are integers >= 1
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of results per page, valid values are 1 through 5000
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`
}

// InsertDestinationsForRouteJSONBody defines parameters for InsertDestinationsForRoute.
type InsertDestinationsForRouteJSONBody = []struct {
	// App App to which the route destination directs traffic. Must provide either app or service instance.
	App struct {
		// Guid App GUID
		Guid    *openapi_types.UUID `json:"guid,omitempty"`
		Process *struct {
			// Guid Process GUID
			Guid *openapi_types.UUID `json:"guid,omitempty"`

			// Type Process type
			Type *string `json:"type,omitempty"`
		} `json:"process,omitempty"`
	} `json:"app"`

	// Port Port of the destination that receives traffic.
	Port *int `json:"port,omitempty"`

	// Protocol Protocol of the destination that receives traffic. Defaults to 'http1' when not specified for HTTP routes, and is ignored for TCP routes.
	Protocol *InsertDestinationsForRouteJSONBodyProtocol `json:"protocol,omitempty"`

	// ServiceInstance Service instance to which the route destination directs traffic. Must provide either app or service instance.
	ServiceInstance *struct {
		// Guid Service Instance GUID
		Guid *openapi_types.UUID `json:"guid,omitempty"`
	} `json:"service_instance,omitempty"`

	// Weight Weight of the destination. Routes will equally distribute the traffic to all destinations with the same weight.
	Weight *int `json:"weight,omitempty"`
}

// InsertDestinationsForRouteJSONBodyProtocol defines parameters for InsertDestinationsForRoute.
type InsertDestinationsForRouteJSONBodyProtocol string

// ReplaceDestinationsForRouteJSONBody defines parameters for ReplaceDestinationsForRoute.
type ReplaceDestinationsForRouteJSONBody = []struct {
	// App App to which the route destination directs traffic. Must provide either app or service instance.
	App struct {
		// Guid App GUID
		Guid    *openapi_types.UUID `json:"guid,omitempty"`
		Process *struct {
			// Guid Process GUID
			Guid *openapi_types.UUID `json:"guid,omitempty"`

			// Type Process type
			Type *string `json:"type,omitempty"`
		} `json:"process,omitempty"`
	} `json:"app"`

	// Port Port of the destination that receives traffic.
	Port *int `json:"port,omitempty"`

	// Protocol Protocol of the destination that receives traffic. Defaults to 'http1' when not specified for HTTP routes, and is ignored for TCP routes.
	Protocol *ReplaceDestinationsForRouteJSONBodyProtocol `json:"protocol,omitempty"`

	// ServiceInstance Service instance to which the route destination directs traffic. Must provide either app or service instance.
	ServiceInstance *struct {
		// Guid Service Instance GUID
		Guid *openapi_types.UUID `json:"guid,omitempty"`
	} `json:"service_instance,omitempty"`

	// Weight Weight of the destination. Routes will equally distribute the traffic to all destinations with the same weight.
	Weight *int `json:"weight,omitempty"`
}

// ReplaceDestinationsForRouteJSONBodyProtocol defines parameters for ReplaceDestinationsForRoute.
type ReplaceDestinationsForRouteJSONBodyProtocol string

// UpdateDestinationProtocolForRouteJSONBody defines parameters for UpdateDestinationProtocolForRoute.
type UpdateDestinationProtocolForRouteJSONBody struct {
	// Protocol Protocol of the destination
	Protocol UpdateDestinationProtocolForRouteJSONBodyProtocol `json:"protocol"`
}

// UpdateDestinationProtocolForRouteJSONBodyProtocol defines parameters for UpdateDestinationProtocolForRoute.
type UpdateDestinationProtocolForRouteJSONBodyProtocol string

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	// Page Page to display; valid values are integers >= 1
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of results per page, valid values are 1 through 5000
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// OrderBy Order results by a specific field. Prepend with - to sort descending.
	OrderBy *OrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// CreatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	CreatedAts *CreatedAts `form:"created_ats,omitempty" json:"created_ats,omitempty"`

	// UpdatedAts Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed.
	UpdatedAts *UpdatedAts `form:"updated_ats,omitempty" json:"updated_ats,omitempty"`

	// Guids Comma-delimited list of user guids to filter by
	Guids *[]string `form:"guids,omitempty" json:"guids,omitempty"`

	// Usernames Comma-delimited list of usernames to filter by
	Usernames *[]string `form:"usernames,omitempty" json:"usernames,omitempty"`

	// Origins Comma-delimited list of user origins to filter by
	Origins *[]string `form:"origins,omitempty" json:"origins,omitempty"`
}

// CreateAppJSONRequestBody defines body for CreateApp for application/json ContentType.
type CreateAppJSONRequestBody CreateAppJSONBody

// UpdateAppJSONRequestBody defines body for UpdateApp for application/json ContentType.
type UpdateAppJSONRequestBody UpdateAppJSONBody

// SetCurrentDropletForAppJSONRequestBody defines body for SetCurrentDropletForApp for application/json ContentType.
type SetCurrentDropletForAppJSONRequestBody SetCurrentDropletForAppJSONBody

// UpdateAppFeatureJSONRequestBody defines body for UpdateAppFeature for application/json ContentType.
type UpdateAppFeatureJSONRequestBody UpdateAppFeatureJSONBody

// UpdateRevisionJSONRequestBody defines body for UpdateRevision for application/json ContentType.
type UpdateRevisionJSONRequestBody UpdateRevisionJSONBody

// CreateAuditEventJSONRequestBody defines body for CreateAuditEvent for application/json ContentType.
type CreateAuditEventJSONRequestBody CreateAuditEventJSONBody

// CreateBuildpackJSONRequestBody defines body for CreateBuildpack for application/json ContentType.
type CreateBuildpackJSONRequestBody CreateBuildpackJSONBody

// PpdateBuildpackJSONRequestBody defines body for PpdateBuildpack for application/json ContentType.
type PpdateBuildpackJSONRequestBody PpdateBuildpackJSONBody

// UploadBuildpackMultipartRequestBody defines body for UploadBuildpack for multipart/form-data ContentType.
type UploadBuildpackMultipartRequestBody UploadBuildpackMultipartBody

// CreateBuildJSONRequestBody defines body for CreateBuild for application/json ContentType.
type CreateBuildJSONRequestBody CreateBuildJSONBody

// UpdateBuildJSONRequestBody defines body for UpdateBuild for application/json ContentType.
type UpdateBuildJSONRequestBody UpdateBuildJSONBody

// CreateDeploymentJSONRequestBody defines body for CreateDeployment for application/json ContentType.
type CreateDeploymentJSONRequestBody CreateDeploymentJSONBody

// UpdateDeploymentJSONRequestBody defines body for UpdateDeployment for application/json ContentType.
type UpdateDeploymentJSONRequestBody UpdateDeploymentJSONBody

// CreateDomainJSONRequestBody defines body for CreateDomain for application/json ContentType.
type CreateDomainJSONRequestBody CreateDomainJSONBody

// UpdateDomainJSONRequestBody defines body for UpdateDomain for application/json ContentType.
type UpdateDomainJSONRequestBody UpdateDomainJSONBody

// ShareDomainJSONRequestBody defines body for ShareDomain for application/json ContentType.
type ShareDomainJSONRequestBody ShareDomainJSONBody

// CreateDropletJSONRequestBody defines body for CreateDroplet for application/json ContentType.
type CreateDropletJSONRequestBody CreateDropletJSONBody

// UpdateDropletJSONRequestBody defines body for UpdateDroplet for application/json ContentType.
type UpdateDropletJSONRequestBody UpdateDropletJSONBody

// UploadDropletMultipartRequestBody defines body for UploadDroplet for multipart/form-data ContentType.
type UploadDropletMultipartRequestBody UploadDropletMultipartBody

// UpdateRunningEnvironmentVariableGroupJSONRequestBody defines body for UpdateRunningEnvironmentVariableGroup for application/json ContentType.
type UpdateRunningEnvironmentVariableGroupJSONRequestBody UpdateRunningEnvironmentVariableGroupJSONBody

// UpdateStagingEnvironmentVariableGroupJSONRequestBody defines body for UpdateStagingEnvironmentVariableGroup for application/json ContentType.
type UpdateStagingEnvironmentVariableGroupJSONRequestBody UpdateStagingEnvironmentVariableGroupJSONBody

// CreateFeatureFlagJSONRequestBody defines body for CreateFeatureFlag for application/json ContentType.
type CreateFeatureFlagJSONRequestBody CreateFeatureFlagJSONBody

// UpdateFeatureFlagJSONRequestBody defines body for UpdateFeatureFlag for application/json ContentType.
type UpdateFeatureFlagJSONRequestBody UpdateFeatureFlagJSONBody

// CreateIsolationSegmentJSONRequestBody defines body for CreateIsolationSegment for application/json ContentType.
type CreateIsolationSegmentJSONRequestBody CreateIsolationSegmentJSONBody

// UpdateIsolationSegmentJSONRequestBody defines body for UpdateIsolationSegment for application/json ContentType.
type UpdateIsolationSegmentJSONRequestBody UpdateIsolationSegmentJSONBody

// EntitleOrganizationsForIsolationSegmentJSONRequestBody defines body for EntitleOrganizationsForIsolationSegment for application/json ContentType.
type EntitleOrganizationsForIsolationSegmentJSONRequestBody = RelationshipToMany

// CreatePackageJSONRequestBody defines body for CreatePackage for application/json ContentType.
type CreatePackageJSONRequestBody CreatePackageJSONBody

// UpdatePackageJSONRequestBody defines body for UpdatePackage for application/json ContentType.
type UpdatePackageJSONRequestBody UpdatePackageJSONBody

// UploadPackageBitsMultipartRequestBody defines body for UploadPackageBits for multipart/form-data ContentType.
type UploadPackageBitsMultipartRequestBody UploadPackageBitsMultipartBody

// CreateRoleJSONRequestBody defines body for CreateRole for application/json ContentType.
type CreateRoleJSONRequestBody CreateRoleJSONBody

// CreateRouteJSONRequestBody defines body for CreateRoute for application/json ContentType.
type CreateRouteJSONRequestBody CreateRouteJSONBody

// InsertDestinationsForRouteJSONRequestBody defines body for InsertDestinationsForRoute for application/json ContentType.
type InsertDestinationsForRouteJSONRequestBody = InsertDestinationsForRouteJSONBody

// ReplaceDestinationsForRouteJSONRequestBody defines body for ReplaceDestinationsForRoute for application/json ContentType.
type ReplaceDestinationsForRouteJSONRequestBody = ReplaceDestinationsForRouteJSONBody

// UpdateDestinationProtocolForRouteJSONRequestBody defines body for UpdateDestinationProtocolForRoute for application/json ContentType.
type UpdateDestinationProtocolForRouteJSONRequestBody UpdateDestinationProtocolForRouteJSONBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody = UserCreate

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = UserUpdate

// Getter for additional properties for Lifecycle_Data. Returns the specified
// element and whether it was found
func (a Lifecycle_Data) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Lifecycle_Data
func (a *Lifecycle_Data) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Lifecycle_Data to handle AdditionalProperties
func (a *Lifecycle_Data) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["buildpacks"]; found {
		err = json.Unmarshal(raw, &a.Buildpacks)
		if err != nil {
			return fmt.Errorf("error reading 'buildpacks': %w", err)
		}
		delete(object, "buildpacks")
	}

	if raw, found := object["credentials"]; found {
		err = json.Unmarshal(raw, &a.Credentials)
		if err != nil {
			return fmt.Errorf("error reading 'credentials': %w", err)
		}
		delete(object, "credentials")
	}

	if raw, found := object["stack"]; found {
		err = json.Unmarshal(raw, &a.Stack)
		if err != nil {
			return fmt.Errorf("error reading 'stack': %w", err)
		}
		delete(object, "stack")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Lifecycle_Data to handle AdditionalProperties
func (a Lifecycle_Data) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Buildpacks != nil {
		object["buildpacks"], err = json.Marshal(a.Buildpacks)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'buildpacks': %w", err)
		}
	}

	if a.Credentials != nil {
		object["credentials"], err = json.Marshal(a.Credentials)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'credentials': %w", err)
		}
	}

	if a.Stack != nil {
		object["stack"], err = json.Marshal(a.Stack)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stack': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get root
	// (GET /)
	GetRoot(ctx echo.Context) error
	// Get v3 root
	// (GET /v3)
	GetRootV3(ctx echo.Context) error
	// List app usage events
	// (GET /v3/app_usage_events)
	ListAppUsageEvents(ctx echo.Context, params ListAppUsageEventsParams) error
	// Purge and seed app usage events
	// (POST /v3/app_usage_events/actions/destructively_purge_all_and_reseed)
	PurgeAndSeedAppUsageEvents(ctx echo.Context) error
	// Get an app usage event
	// (GET /v3/app_usage_events/{guid})
	GetAppUsageEvent(ctx echo.Context, guid Guid) error
	// List apps
	// (GET /v3/apps)
	ListApps(ctx echo.Context, params ListAppsParams) error
	// Create an app
	// (POST /v3/apps)
	CreateApp(ctx echo.Context) error
	// List builds for an app
	// (GET /v3/apps/{app_guid}/builds)
	ListBuildsForApp(ctx echo.Context, appGuid openapi_types.UUID, params ListBuildsForAppParams) error
	// List app features
	// (GET /v3/apps/{app_guid}/features)
	ListAppFeatures(ctx echo.Context, appGuid openapi_types.UUID) error
	// Delete an app
	// (DELETE /v3/apps/{guid})
	DeleteApp(ctx echo.Context, guid Guid) error
	// Retrieve an app
	// (GET /v3/apps/{guid})
	GetApp(ctx echo.Context, guid Guid) error
	// Update an app
	// (PATCH /v3/apps/{guid})
	UpdateApp(ctx echo.Context, guid Guid) error
	// Restart an app
	// (POST /v3/apps/{guid}/actions/restart)
	RestartApp(ctx echo.Context, guid Guid) error
	// Start an app
	// (POST /v3/apps/{guid}/actions/start)
	StartApp(ctx echo.Context, guid Guid) error
	// Stop an app
	// (POST /v3/apps/{guid}/actions/stop)
	StopApp(ctx echo.Context, guid Guid) error
	// Get current droplet for an app
	// (GET /v3/apps/{guid}/droplets/current)
	GetCurrentDropletForApp(ctx echo.Context, guid Guid) error
	// Set the current droplet for an app
	// (PATCH /v3/apps/{guid}/droplets/current)
	SetCurrentDropletForApp(ctx echo.Context, guid Guid) error
	// Update app feature
	// (PATCH /v3/apps/{guid}/features/{feature_name})
	UpdateAppFeature(ctx echo.Context, guid openapi_types.UUID, featureName string) error
	// List packages for an app
	// (GET /v3/apps/{guid}/packages)
	ListPackagesForApp(ctx echo.Context, guid openapi_types.UUID, params ListPackagesForAppParams) error
	// List revisions for an app
	// (GET /v3/apps/{guid}/revisions)
	ListRevisionsForApp(ctx echo.Context, guid Guid, params ListRevisionsForAppParams) error
	// List deployed revisions for an app
	// (GET /v3/apps/{guid}/revisions/deployed)
	ListDeployedRevisionsForApp(ctx echo.Context, guid Guid, params ListDeployedRevisionsForAppParams) error
	// Get a revision
	// (GET /v3/apps/{guid}/revisions/{version})
	GetRevision(ctx echo.Context, guid Guid, version int) error
	// Update a revision
	// (PATCH /v3/apps/{guid}/revisions/{version})
	UpdateRevision(ctx echo.Context, guid Guid, version int) error
	// Get environment variables for a revision
	// (GET /v3/apps/{guid}/revisions/{version}/environment_variables)
	GetEnvironmentVariablesForRevision(ctx echo.Context, guid Guid, version int) error
	// List audit events
	// (GET /v3/audit_events)
	ListAuditEvents(ctx echo.Context, params ListAuditEventsParams) error
	// Create an audit event
	// (POST /v3/audit_events)
	CreateAuditEvent(ctx echo.Context) error
	// Retrieve an audit event
	// (GET /v3/audit_events/{guid})
	GetAuditEvent(ctx echo.Context, guid Guid) error
	// List buildpacks
	// (GET /v3/buildpacks)
	ListBuildpacks(ctx echo.Context, params ListBuildpacksParams) error
	// Create a buildpack
	// (POST /v3/buildpacks)
	CreateBuildpack(ctx echo.Context) error
	// Delete a buildpack
	// (DELETE /v3/buildpacks/{guid})
	DeleteBuildpack(ctx echo.Context, guid Guid) error
	// Retrieve a buildpack
	// (GET /v3/buildpacks/{guid})
	GetBuildpack(ctx echo.Context, guid Guid) error
	// Update a buildpack
	// (PATCH /v3/buildpacks/{guid})
	PpdateBuildpack(ctx echo.Context, guid Guid) error
	// Upload a buildpack
	// (POST /v3/buildpacks/{guid}/upload)
	UploadBuildpack(ctx echo.Context, guid Guid) error
	// List builds
	// (GET /v3/builds)
	ListBuilds(ctx echo.Context, params ListBuildsParams) error
	// Create a build
	// (POST /v3/builds)
	CreateBuild(ctx echo.Context) error
	// Delete a build
	// (DELETE /v3/builds/{guid})
	DeleteBuild(ctx echo.Context, guid Guid) error
	// Retrieve a build
	// (GET /v3/builds/{guid})
	GetBuild(ctx echo.Context, guid Guid) error
	// Update a build
	// (PATCH /v3/builds/{guid})
	UpdateBuild(ctx echo.Context, guid Guid) error
	// List deployments
	// (GET /v3/deployments)
	ListDeployments(ctx echo.Context, params ListDeploymentsParams) error
	// Create a deployment
	// (POST /v3/deployments)
	CreateDeployment(ctx echo.Context) error
	// Delete a deployment
	// (DELETE /v3/deployments/{guid})
	DeleteDeployment(ctx echo.Context, guid Guid) error
	// Retrieve a deployment
	// (GET /v3/deployments/{guid})
	GetDeployment(ctx echo.Context, guid Guid) error
	// Update a deployment
	// (PATCH /v3/deployments/{guid})
	UpdateDeployment(ctx echo.Context, guid Guid) error
	// Cancel a deployment
	// (POST /v3/deployments/{guid}/actions/cancel)
	CancelDeployment(ctx echo.Context, guid Guid) error
	// Continue a deployment
	// (POST /v3/deployments/{guid}/actions/continue)
	ContinueDeployment(ctx echo.Context, guid Guid) error
	// List domains
	// (GET /v3/domains)
	ListDomains(ctx echo.Context, params ListDomainsParams) error
	// Create a domain
	// (POST /v3/domains)
	CreateDomain(ctx echo.Context) error
	// Delete a domain
	// (DELETE /v3/domains/{guid})
	DeleteDomain(ctx echo.Context, guid Guid) error
	// Retrieve a domain
	// (GET /v3/domains/{guid})
	GetDomain(ctx echo.Context, guid Guid) error
	// Update a domain
	// (PATCH /v3/domains/{guid})
	UpdateDomain(ctx echo.Context, guid Guid) error
	// Share a domain
	// (POST /v3/domains/{guid}/relationships/shared_organizations)
	ShareDomain(ctx echo.Context, guid Guid) error
	// Unshare a domain
	// (DELETE /v3/domains/{guid}/relationships/shared_organizations/{org_guid})
	UnshareDomain(ctx echo.Context, guid Guid, orgGuid openapi_types.UUID) error
	// List droplets
	// (GET /v3/droplets)
	ListDroplets(ctx echo.Context, params ListDropletsParams) error
	// Create a droplet
	// (POST /v3/droplets)
	CreateDroplet(ctx echo.Context) error
	// Delete a droplet
	// (DELETE /v3/droplets/{droplet_guid})
	DeleteDroplet(ctx echo.Context, dropletGuid DropletGuid) error
	// Retrieve a droplet
	// (GET /v3/droplets/{droplet_guid})
	GetDroplet(ctx echo.Context, dropletGuid DropletGuid) error
	// Update a droplet
	// (PATCH /v3/droplets/{droplet_guid})
	UpdateDroplet(ctx echo.Context, dropletGuid DropletGuid) error
	// Download a droplet
	// (GET /v3/droplets/{droplet_guid}/download)
	DownloadDroplet(ctx echo.Context, dropletGuid DropletGuid) error
	// Upload a droplet
	// (POST /v3/droplets/{droplet_guid}/upload)
	UploadDroplet(ctx echo.Context, dropletGuid DropletGuid) error
	// Get running environment variable group
	// (GET /v3/environment_variable_groups/running)
	GetRunningEnvironmentVariableGroup(ctx echo.Context) error
	// Update running environment variable group
	// (PATCH /v3/environment_variable_groups/running)
	UpdateRunningEnvironmentVariableGroup(ctx echo.Context) error
	// Get staging environment variable group
	// (GET /v3/environment_variable_groups/staging)
	GetStagingEnvironmentVariableGroup(ctx echo.Context) error
	// Update staging environment variable group
	// (PATCH /v3/environment_variable_groups/staging)
	UpdateStagingEnvironmentVariableGroup(ctx echo.Context) error
	// List feature flags
	// (GET /v3/feature_flags)
	ListFeatureFlags(ctx echo.Context, params ListFeatureFlagsParams) error
	// Create a feature flag
	// (POST /v3/feature_flags)
	CreateFeatureFlag(ctx echo.Context) error
	// Retrieve a feature flag
	// (GET /v3/feature_flags/{name})
	GetFeatureFlag(ctx echo.Context, name string) error
	// Update a feature flag
	// (PATCH /v3/feature_flags/{name})
	UpdateFeatureFlag(ctx echo.Context, name string) error
	// Get platform info
	// (GET /v3/info)
	GetPlatformInfo(ctx echo.Context) error
	// Get platform usage summary
	// (GET /v3/info/usage_summary)
	GetPlatformUsageSummary(ctx echo.Context) error
	// List isolation segments
	// (GET /v3/isolation_segments)
	ListIsolationSegments(ctx echo.Context, params ListIsolationSegmentsParams) error
	// Create an isolation segment
	// (POST /v3/isolation_segments)
	CreateIsolationSegment(ctx echo.Context) error
	// Delete an isolation segment
	// (DELETE /v3/isolation_segments/{guid})
	DeleteIsolationSegment(ctx echo.Context, guid Guid) error
	// Get an isolation segment
	// (GET /v3/isolation_segments/{guid})
	GetIsolationSegment(ctx echo.Context, guid Guid) error
	// Update an isolation segment
	// (PATCH /v3/isolation_segments/{guid})
	UpdateIsolationSegment(ctx echo.Context, guid Guid) error
	// List organizations
	// (GET /v3/isolation_segments/{guid}/relationships/organizations)
	ListOrganizationsForIsolationSegment(ctx echo.Context, guid Guid, params ListOrganizationsForIsolationSegmentParams) error
	// Entitle organizations for isolation segment
	// (POST /v3/isolation_segments/{guid}/relationships/organizations)
	EntitleOrganizationsForIsolationSegment(ctx echo.Context, guid Guid) error
	// Revoke entitlement of an organization
	// (DELETE /v3/isolation_segments/{guid}/relationships/organizations/{org_guid})
	RevokeIsolationSegmentForOrganization(ctx echo.Context, guid Guid, orgGuid openapi_types.UUID) error
	// List spaces
	// (GET /v3/isolation_segments/{guid}/relationships/spaces)
	ListSpacesForIsolationSegment(ctx echo.Context, guid Guid, params ListSpacesForIsolationSegmentParams) error
	// List jobs
	// (GET /v3/jobs)
	ListJobs(ctx echo.Context, params ListJobsParams) error
	// Get a job
	// (GET /v3/jobs/{guid})
	GetJob(ctx echo.Context, guid Guid) error
	// List domains for an organization
	// (GET /v3/organizations/{org_guid}/domains)
	ListDomainsForOrganization(ctx echo.Context, orgGuid openapi_types.UUID, params ListDomainsForOrganizationParams) error
	// Get the default domain
	// (GET /v3/organizations/{org_guid}/domains/default)
	GetDefaultDomain(ctx echo.Context, orgGuid openapi_types.UUID) error
	// List packages
	// (GET /v3/packages)
	ListPackages(ctx echo.Context, params ListPackagesParams) error
	// Create a package
	// (POST /v3/packages)
	CreatePackage(ctx echo.Context) error
	// Delete a package
	// (DELETE /v3/packages/{guid})
	DeletePackage(ctx echo.Context, guid Guid) error
	// Get a package
	// (GET /v3/packages/{guid})
	GetPackage(ctx echo.Context, guid Guid) error
	// Update a package
	// (PATCH /v3/packages/{guid})
	UpdatePackage(ctx echo.Context, guid Guid) error
	// Download package bits
	// (GET /v3/packages/{guid}/download)
	DownloadPackageBits(ctx echo.Context, guid Guid) error
	// Upload package bits
	// (POST /v3/packages/{guid}/upload)
	UploadPackageBits(ctx echo.Context, guid Guid) error
	// List roles
	// (GET /v3/roles)
	ListRoles(ctx echo.Context, params ListRolesParams) error
	// Create a role
	// (POST /v3/roles)
	CreateRole(ctx echo.Context) error
	// Delete a role
	// (DELETE /v3/roles/{guid})
	DeleteRole(ctx echo.Context, guid Guid) error
	// Get a role
	// (GET /v3/roles/{guid})
	GetRole(ctx echo.Context, guid Guid, params GetRoleParams) error
	// List routes
	// (GET /v3/routes)
	ListRoutes(ctx echo.Context, params ListRoutesParams) error
	// Create a route
	// (POST /v3/routes)
	CreateRoute(ctx echo.Context) error
	// List destinations for a route
	// (GET /v3/routes/{guid}/destinations)
	ListDestinationsForRoute(ctx echo.Context, guid Guid, params ListDestinationsForRouteParams) error
	// Insert destinations for a route
	// (POST /v3/routes/{guid}/destinations)
	InsertDestinationsForRoute(ctx echo.Context, guid Guid) error
	// Replace all destinations for a route
	// (PUT /v3/routes/{guid}/destinations)
	ReplaceDestinationsForRoute(ctx echo.Context, guid Guid) error
	// Remove destination for a route
	// (DELETE /v3/routes/{guid}/destinations/{destination_guid})
	RemoveDestinationForRoute(ctx echo.Context, guid Guid, destinationGuid openapi_types.UUID) error
	// Update a destination protocol for a route
	// (PATCH /v3/routes/{guid}/destinations/{destination_guid})
	UpdateDestinationProtocolForRoute(ctx echo.Context, guid Guid, destinationGuid openapi_types.UUID) error
	// Delete unmapped routes for a space
	// (DELETE /v3/spaces/{guid}/routes)
	DeleteUnmappedRoutesForSpace(ctx echo.Context, guid Guid) error
	// List users
	// (GET /v3/users)
	ListUsers(ctx echo.Context, params ListUsersParams) error
	// Create a user
	// (POST /v3/users)
	CreateUser(ctx echo.Context) error
	// Delete a user
	// (DELETE /v3/users/{guid})
	DeleteUser(ctx echo.Context, guid Guid) error
	// Get a user
	// (GET /v3/users/{guid})
	GetUser(ctx echo.Context, guid Guid) error
	// Update a user
	// (PATCH /v3/users/{guid})
	UpdateUser(ctx echo.Context, guid Guid) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetRoot converts echo context to params.
func (w *ServerInterfaceWrapper) GetRoot(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRoot(ctx)
	return err
}

// GetRootV3 converts echo context to params.
func (w *ServerInterfaceWrapper) GetRootV3(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRootV3(ctx)
	return err
}

// ListAppUsageEvents converts echo context to params.
func (w *ServerInterfaceWrapper) ListAppUsageEvents(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.admin", "cloud_controller.admin_read_only", "cloud_controller.global_auditor"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAppUsageEventsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by: %s", err))
	}

	// ------------- Optional query parameter "created_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_ats", ctx.QueryParams(), &params.CreatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_ats: %s", err))
	}

	// ------------- Optional query parameter "after_guid" -------------

	err = runtime.BindQueryParameter("form", true, false, "after_guid", ctx.QueryParams(), &params.AfterGuid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after_guid: %s", err))
	}

	// ------------- Optional query parameter "guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "guids", ctx.QueryParams(), &params.Guids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guids: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAppUsageEvents(ctx, params)
	return err
}

// PurgeAndSeedAppUsageEvents converts echo context to params.
func (w *ServerInterfaceWrapper) PurgeAndSeedAppUsageEvents(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PurgeAndSeedAppUsageEvents(ctx)
	return err
}

// GetAppUsageEvent converts echo context to params.
func (w *ServerInterfaceWrapper) GetAppUsageEvent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.admin", "cloud_controller.admin_read_only", "cloud_controller.global_auditor"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAppUsageEvent(ctx, guid)
	return err
}

// ListApps converts echo context to params.
func (w *ServerInterfaceWrapper) ListApps(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAppsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by: %s", err))
	}

	// ------------- Optional query parameter "created_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_ats", ctx.QueryParams(), &params.CreatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_ats: %s", err))
	}

	// ------------- Optional query parameter "updated_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_ats", ctx.QueryParams(), &params.UpdatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_ats: %s", err))
	}

	// ------------- Optional query parameter "label_selector" -------------

	err = runtime.BindQueryParameter("form", true, false, "label_selector", ctx.QueryParams(), &params.LabelSelector)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter label_selector: %s", err))
	}

	// ------------- Optional query parameter "guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "guids", ctx.QueryParams(), &params.Guids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guids: %s", err))
	}

	// ------------- Optional query parameter "names" -------------

	err = runtime.BindQueryParameter("form", true, false, "names", ctx.QueryParams(), &params.Names)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names: %s", err))
	}

	// ------------- Optional query parameter "space_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "space_guids", ctx.QueryParams(), &params.SpaceGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter space_guids: %s", err))
	}

	// ------------- Optional query parameter "organization_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "organization_guids", ctx.QueryParams(), &params.OrganizationGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization_guids: %s", err))
	}

	// ------------- Optional query parameter "stacks" -------------

	err = runtime.BindQueryParameter("form", true, false, "stacks", ctx.QueryParams(), &params.Stacks)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stacks: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListApps(ctx, params)
	return err
}

// CreateApp converts echo context to params.
func (w *ServerInterfaceWrapper) CreateApp(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateApp(ctx)
	return err
}

// ListBuildsForApp converts echo context to params.
func (w *ServerInterfaceWrapper) ListBuildsForApp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "app_guid" -------------
	var appGuid openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "app_guid", runtime.ParamLocationPath, ctx.Param("app_guid"), &appGuid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter app_guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBuildsForAppParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by: %s", err))
	}

	// ------------- Optional query parameter "created_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_ats", ctx.QueryParams(), &params.CreatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_ats: %s", err))
	}

	// ------------- Optional query parameter "updated_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_ats", ctx.QueryParams(), &params.UpdatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_ats: %s", err))
	}

	// ------------- Optional query parameter "label_selector" -------------

	err = runtime.BindQueryParameter("form", true, false, "label_selector", ctx.QueryParams(), &params.LabelSelector)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter label_selector: %s", err))
	}

	// ------------- Optional query parameter "app_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "app_guids", ctx.QueryParams(), &params.AppGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter app_guids: %s", err))
	}

	// ------------- Optional query parameter "package_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "package_guids", ctx.QueryParams(), &params.PackageGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter package_guids: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListBuildsForApp(ctx, appGuid, params)
	return err
}

// ListAppFeatures converts echo context to params.
func (w *ServerInterfaceWrapper) ListAppFeatures(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "app_guid" -------------
	var appGuid openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "app_guid", runtime.ParamLocationPath, ctx.Param("app_guid"), &appGuid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter app_guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAppFeatures(ctx, appGuid)
	return err
}

// DeleteApp converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteApp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteApp(ctx, guid)
	return err
}

// GetApp converts echo context to params.
func (w *ServerInterfaceWrapper) GetApp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApp(ctx, guid)
	return err
}

// UpdateApp converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateApp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateApp(ctx, guid)
	return err
}

// RestartApp converts echo context to params.
func (w *ServerInterfaceWrapper) RestartApp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RestartApp(ctx, guid)
	return err
}

// StartApp converts echo context to params.
func (w *ServerInterfaceWrapper) StartApp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StartApp(ctx, guid)
	return err
}

// StopApp converts echo context to params.
func (w *ServerInterfaceWrapper) StopApp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StopApp(ctx, guid)
	return err
}

// GetCurrentDropletForApp converts echo context to params.
func (w *ServerInterfaceWrapper) GetCurrentDropletForApp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCurrentDropletForApp(ctx, guid)
	return err
}

// SetCurrentDropletForApp converts echo context to params.
func (w *ServerInterfaceWrapper) SetCurrentDropletForApp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetCurrentDropletForApp(ctx, guid)
	return err
}

// UpdateAppFeature converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateAppFeature(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	// ------------- Path parameter "feature_name" -------------
	var featureName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "feature_name", runtime.ParamLocationPath, ctx.Param("feature_name"), &featureName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter feature_name: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateAppFeature(ctx, guid, featureName)
	return err
}

// ListPackagesForApp converts echo context to params.
func (w *ServerInterfaceWrapper) ListPackagesForApp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPackagesForAppParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by: %s", err))
	}

	// ------------- Optional query parameter "created_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_ats", ctx.QueryParams(), &params.CreatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_ats: %s", err))
	}

	// ------------- Optional query parameter "updated_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_ats", ctx.QueryParams(), &params.UpdatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_ats: %s", err))
	}

	// ------------- Optional query parameter "label_selector" -------------

	err = runtime.BindQueryParameter("form", true, false, "label_selector", ctx.QueryParams(), &params.LabelSelector)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter label_selector: %s", err))
	}

	// ------------- Optional query parameter "guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "guids", ctx.QueryParams(), &params.Guids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guids: %s", err))
	}

	// ------------- Optional query parameter "states" -------------

	err = runtime.BindQueryParameter("form", true, false, "states", ctx.QueryParams(), &params.States)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter states: %s", err))
	}

	// ------------- Optional query parameter "types" -------------

	err = runtime.BindQueryParameter("form", true, false, "types", ctx.QueryParams(), &params.Types)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter types: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListPackagesForApp(ctx, guid, params)
	return err
}

// ListRevisionsForApp converts echo context to params.
func (w *ServerInterfaceWrapper) ListRevisionsForApp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRevisionsForAppParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by: %s", err))
	}

	// ------------- Optional query parameter "created_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_ats", ctx.QueryParams(), &params.CreatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_ats: %s", err))
	}

	// ------------- Optional query parameter "updated_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_ats", ctx.QueryParams(), &params.UpdatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_ats: %s", err))
	}

	// ------------- Optional query parameter "label_selector" -------------

	err = runtime.BindQueryParameter("form", true, false, "label_selector", ctx.QueryParams(), &params.LabelSelector)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter label_selector: %s", err))
	}

	// ------------- Optional query parameter "versions" -------------

	err = runtime.BindQueryParameter("form", true, false, "versions", ctx.QueryParams(), &params.Versions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter versions: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListRevisionsForApp(ctx, guid, params)
	return err
}

// ListDeployedRevisionsForApp converts echo context to params.
func (w *ServerInterfaceWrapper) ListDeployedRevisionsForApp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDeployedRevisionsForAppParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by: %s", err))
	}

	// ------------- Optional query parameter "created_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_ats", ctx.QueryParams(), &params.CreatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_ats: %s", err))
	}

	// ------------- Optional query parameter "updated_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_ats", ctx.QueryParams(), &params.UpdatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_ats: %s", err))
	}

	// ------------- Optional query parameter "label_selector" -------------

	err = runtime.BindQueryParameter("form", true, false, "label_selector", ctx.QueryParams(), &params.LabelSelector)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter label_selector: %s", err))
	}

	// ------------- Optional query parameter "versions" -------------

	err = runtime.BindQueryParameter("form", true, false, "versions", ctx.QueryParams(), &params.Versions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter versions: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListDeployedRevisionsForApp(ctx, guid, params)
	return err
}

// GetRevision converts echo context to params.
func (w *ServerInterfaceWrapper) GetRevision(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	// ------------- Path parameter "version" -------------
	var version int

	err = runtime.BindStyledParameterWithLocation("simple", false, "version", runtime.ParamLocationPath, ctx.Param("version"), &version)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter version: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRevision(ctx, guid, version)
	return err
}

// UpdateRevision converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateRevision(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	// ------------- Path parameter "version" -------------
	var version int

	err = runtime.BindStyledParameterWithLocation("simple", false, "version", runtime.ParamLocationPath, ctx.Param("version"), &version)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter version: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateRevision(ctx, guid, version)
	return err
}

// GetEnvironmentVariablesForRevision converts echo context to params.
func (w *ServerInterfaceWrapper) GetEnvironmentVariablesForRevision(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	// ------------- Path parameter "version" -------------
	var version int

	err = runtime.BindStyledParameterWithLocation("simple", false, "version", runtime.ParamLocationPath, ctx.Param("version"), &version)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter version: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEnvironmentVariablesForRevision(ctx, guid, version)
	return err
}

// ListAuditEvents converts echo context to params.
func (w *ServerInterfaceWrapper) ListAuditEvents(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAuditEventsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by: %s", err))
	}

	// ------------- Optional query parameter "created_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_ats", ctx.QueryParams(), &params.CreatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_ats: %s", err))
	}

	// ------------- Optional query parameter "updated_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_ats", ctx.QueryParams(), &params.UpdatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_ats: %s", err))
	}

	// ------------- Optional query parameter "entity_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "entity_type", ctx.QueryParams(), &params.EntityType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entity_type: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "target_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "target_guids", ctx.QueryParams(), &params.TargetGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter target_guids: %s", err))
	}

	// ------------- Optional query parameter "space_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "space_guids", ctx.QueryParams(), &params.SpaceGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter space_guids: %s", err))
	}

	// ------------- Optional query parameter "organization_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "organization_guids", ctx.QueryParams(), &params.OrganizationGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization_guids: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAuditEvents(ctx, params)
	return err
}

// CreateAuditEvent converts echo context to params.
func (w *ServerInterfaceWrapper) CreateAuditEvent(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateAuditEvent(ctx)
	return err
}

// GetAuditEvent converts echo context to params.
func (w *ServerInterfaceWrapper) GetAuditEvent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAuditEvent(ctx, guid)
	return err
}

// ListBuildpacks converts echo context to params.
func (w *ServerInterfaceWrapper) ListBuildpacks(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBuildpacksParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by: %s", err))
	}

	// ------------- Optional query parameter "created_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_ats", ctx.QueryParams(), &params.CreatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_ats: %s", err))
	}

	// ------------- Optional query parameter "updated_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_ats", ctx.QueryParams(), &params.UpdatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_ats: %s", err))
	}

	// ------------- Optional query parameter "label_selector" -------------

	err = runtime.BindQueryParameter("form", true, false, "label_selector", ctx.QueryParams(), &params.LabelSelector)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter label_selector: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "stacks" -------------

	err = runtime.BindQueryParameter("form", true, false, "stacks", ctx.QueryParams(), &params.Stacks)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stacks: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListBuildpacks(ctx, params)
	return err
}

// CreateBuildpack converts echo context to params.
func (w *ServerInterfaceWrapper) CreateBuildpack(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateBuildpack(ctx)
	return err
}

// DeleteBuildpack converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteBuildpack(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteBuildpack(ctx, guid)
	return err
}

// GetBuildpack converts echo context to params.
func (w *ServerInterfaceWrapper) GetBuildpack(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBuildpack(ctx, guid)
	return err
}

// PpdateBuildpack converts echo context to params.
func (w *ServerInterfaceWrapper) PpdateBuildpack(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PpdateBuildpack(ctx, guid)
	return err
}

// UploadBuildpack converts echo context to params.
func (w *ServerInterfaceWrapper) UploadBuildpack(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UploadBuildpack(ctx, guid)
	return err
}

// ListBuilds converts echo context to params.
func (w *ServerInterfaceWrapper) ListBuilds(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBuildsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by: %s", err))
	}

	// ------------- Optional query parameter "created_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_ats", ctx.QueryParams(), &params.CreatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_ats: %s", err))
	}

	// ------------- Optional query parameter "updated_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_ats", ctx.QueryParams(), &params.UpdatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_ats: %s", err))
	}

	// ------------- Optional query parameter "label_selector" -------------

	err = runtime.BindQueryParameter("form", true, false, "label_selector", ctx.QueryParams(), &params.LabelSelector)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter label_selector: %s", err))
	}

	// ------------- Optional query parameter "app_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "app_guids", ctx.QueryParams(), &params.AppGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter app_guids: %s", err))
	}

	// ------------- Optional query parameter "package_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "package_guids", ctx.QueryParams(), &params.PackageGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter package_guids: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListBuilds(ctx, params)
	return err
}

// CreateBuild converts echo context to params.
func (w *ServerInterfaceWrapper) CreateBuild(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateBuild(ctx)
	return err
}

// DeleteBuild converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteBuild(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteBuild(ctx, guid)
	return err
}

// GetBuild converts echo context to params.
func (w *ServerInterfaceWrapper) GetBuild(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBuild(ctx, guid)
	return err
}

// UpdateBuild converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateBuild(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateBuild(ctx, guid)
	return err
}

// ListDeployments converts echo context to params.
func (w *ServerInterfaceWrapper) ListDeployments(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDeploymentsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by: %s", err))
	}

	// ------------- Optional query parameter "created_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_ats", ctx.QueryParams(), &params.CreatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_ats: %s", err))
	}

	// ------------- Optional query parameter "updated_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_ats", ctx.QueryParams(), &params.UpdatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_ats: %s", err))
	}

	// ------------- Optional query parameter "label_selector" -------------

	err = runtime.BindQueryParameter("form", true, false, "label_selector", ctx.QueryParams(), &params.LabelSelector)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter label_selector: %s", err))
	}

	// ------------- Optional query parameter "app_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "app_guids", ctx.QueryParams(), &params.AppGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter app_guids: %s", err))
	}

	// ------------- Optional query parameter "states" -------------

	err = runtime.BindQueryParameter("form", true, false, "states", ctx.QueryParams(), &params.States)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter states: %s", err))
	}

	// ------------- Optional query parameter "status_reasons" -------------

	err = runtime.BindQueryParameter("form", true, false, "status_reasons", ctx.QueryParams(), &params.StatusReasons)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status_reasons: %s", err))
	}

	// ------------- Optional query parameter "status_values" -------------

	err = runtime.BindQueryParameter("form", true, false, "status_values", ctx.QueryParams(), &params.StatusValues)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status_values: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListDeployments(ctx, params)
	return err
}

// CreateDeployment converts echo context to params.
func (w *ServerInterfaceWrapper) CreateDeployment(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateDeployment(ctx)
	return err
}

// DeleteDeployment converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteDeployment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteDeployment(ctx, guid)
	return err
}

// GetDeployment converts echo context to params.
func (w *ServerInterfaceWrapper) GetDeployment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDeployment(ctx, guid)
	return err
}

// UpdateDeployment converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateDeployment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateDeployment(ctx, guid)
	return err
}

// CancelDeployment converts echo context to params.
func (w *ServerInterfaceWrapper) CancelDeployment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CancelDeployment(ctx, guid)
	return err
}

// ContinueDeployment converts echo context to params.
func (w *ServerInterfaceWrapper) ContinueDeployment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ContinueDeployment(ctx, guid)
	return err
}

// ListDomains converts echo context to params.
func (w *ServerInterfaceWrapper) ListDomains(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDomainsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by: %s", err))
	}

	// ------------- Optional query parameter "created_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_ats", ctx.QueryParams(), &params.CreatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_ats: %s", err))
	}

	// ------------- Optional query parameter "updated_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_ats", ctx.QueryParams(), &params.UpdatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_ats: %s", err))
	}

	// ------------- Optional query parameter "label_selector" -------------

	err = runtime.BindQueryParameter("form", true, false, "label_selector", ctx.QueryParams(), &params.LabelSelector)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter label_selector: %s", err))
	}

	// ------------- Optional query parameter "guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "guids", ctx.QueryParams(), &params.Guids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guids: %s", err))
	}

	// ------------- Optional query parameter "names" -------------

	err = runtime.BindQueryParameter("form", true, false, "names", ctx.QueryParams(), &params.Names)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names: %s", err))
	}

	// ------------- Optional query parameter "organization_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "organization_guids", ctx.QueryParams(), &params.OrganizationGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization_guids: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListDomains(ctx, params)
	return err
}

// CreateDomain converts echo context to params.
func (w *ServerInterfaceWrapper) CreateDomain(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateDomain(ctx)
	return err
}

// DeleteDomain converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteDomain(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteDomain(ctx, guid)
	return err
}

// GetDomain converts echo context to params.
func (w *ServerInterfaceWrapper) GetDomain(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDomain(ctx, guid)
	return err
}

// UpdateDomain converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateDomain(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateDomain(ctx, guid)
	return err
}

// ShareDomain converts echo context to params.
func (w *ServerInterfaceWrapper) ShareDomain(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ShareDomain(ctx, guid)
	return err
}

// UnshareDomain converts echo context to params.
func (w *ServerInterfaceWrapper) UnshareDomain(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	// ------------- Path parameter "org_guid" -------------
	var orgGuid openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "org_guid", runtime.ParamLocationPath, ctx.Param("org_guid"), &orgGuid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter org_guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnshareDomain(ctx, guid, orgGuid)
	return err
}

// ListDroplets converts echo context to params.
func (w *ServerInterfaceWrapper) ListDroplets(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDropletsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by: %s", err))
	}

	// ------------- Optional query parameter "created_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_ats", ctx.QueryParams(), &params.CreatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_ats: %s", err))
	}

	// ------------- Optional query parameter "updated_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_ats", ctx.QueryParams(), &params.UpdatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_ats: %s", err))
	}

	// ------------- Optional query parameter "label_selector" -------------

	err = runtime.BindQueryParameter("form", true, false, "label_selector", ctx.QueryParams(), &params.LabelSelector)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter label_selector: %s", err))
	}

	// ------------- Optional query parameter "guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "guids", ctx.QueryParams(), &params.Guids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guids: %s", err))
	}

	// ------------- Optional query parameter "states" -------------

	err = runtime.BindQueryParameter("form", true, false, "states", ctx.QueryParams(), &params.States)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter states: %s", err))
	}

	// ------------- Optional query parameter "app_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "app_guids", ctx.QueryParams(), &params.AppGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter app_guids: %s", err))
	}

	// ------------- Optional query parameter "space_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "space_guids", ctx.QueryParams(), &params.SpaceGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter space_guids: %s", err))
	}

	// ------------- Optional query parameter "organization_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "organization_guids", ctx.QueryParams(), &params.OrganizationGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization_guids: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListDroplets(ctx, params)
	return err
}

// CreateDroplet converts echo context to params.
func (w *ServerInterfaceWrapper) CreateDroplet(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateDroplet(ctx)
	return err
}

// DeleteDroplet converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteDroplet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "droplet_guid" -------------
	var dropletGuid DropletGuid

	err = runtime.BindStyledParameterWithLocation("simple", false, "droplet_guid", runtime.ParamLocationPath, ctx.Param("droplet_guid"), &dropletGuid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter droplet_guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteDroplet(ctx, dropletGuid)
	return err
}

// GetDroplet converts echo context to params.
func (w *ServerInterfaceWrapper) GetDroplet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "droplet_guid" -------------
	var dropletGuid DropletGuid

	err = runtime.BindStyledParameterWithLocation("simple", false, "droplet_guid", runtime.ParamLocationPath, ctx.Param("droplet_guid"), &dropletGuid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter droplet_guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDroplet(ctx, dropletGuid)
	return err
}

// UpdateDroplet converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateDroplet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "droplet_guid" -------------
	var dropletGuid DropletGuid

	err = runtime.BindStyledParameterWithLocation("simple", false, "droplet_guid", runtime.ParamLocationPath, ctx.Param("droplet_guid"), &dropletGuid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter droplet_guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateDroplet(ctx, dropletGuid)
	return err
}

// DownloadDroplet converts echo context to params.
func (w *ServerInterfaceWrapper) DownloadDroplet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "droplet_guid" -------------
	var dropletGuid DropletGuid

	err = runtime.BindStyledParameterWithLocation("simple", false, "droplet_guid", runtime.ParamLocationPath, ctx.Param("droplet_guid"), &dropletGuid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter droplet_guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DownloadDroplet(ctx, dropletGuid)
	return err
}

// UploadDroplet converts echo context to params.
func (w *ServerInterfaceWrapper) UploadDroplet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "droplet_guid" -------------
	var dropletGuid DropletGuid

	err = runtime.BindStyledParameterWithLocation("simple", false, "droplet_guid", runtime.ParamLocationPath, ctx.Param("droplet_guid"), &dropletGuid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter droplet_guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UploadDroplet(ctx, dropletGuid)
	return err
}

// GetRunningEnvironmentVariableGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetRunningEnvironmentVariableGroup(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRunningEnvironmentVariableGroup(ctx)
	return err
}

// UpdateRunningEnvironmentVariableGroup converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateRunningEnvironmentVariableGroup(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateRunningEnvironmentVariableGroup(ctx)
	return err
}

// GetStagingEnvironmentVariableGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetStagingEnvironmentVariableGroup(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStagingEnvironmentVariableGroup(ctx)
	return err
}

// UpdateStagingEnvironmentVariableGroup converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateStagingEnvironmentVariableGroup(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateStagingEnvironmentVariableGroup(ctx)
	return err
}

// ListFeatureFlags converts echo context to params.
func (w *ServerInterfaceWrapper) ListFeatureFlags(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListFeatureFlagsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by: %s", err))
	}

	// ------------- Optional query parameter "updated_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_ats", ctx.QueryParams(), &params.UpdatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_ats: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListFeatureFlags(ctx, params)
	return err
}

// CreateFeatureFlag converts echo context to params.
func (w *ServerInterfaceWrapper) CreateFeatureFlag(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateFeatureFlag(ctx)
	return err
}

// GetFeatureFlag converts echo context to params.
func (w *ServerInterfaceWrapper) GetFeatureFlag(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFeatureFlag(ctx, name)
	return err
}

// UpdateFeatureFlag converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateFeatureFlag(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateFeatureFlag(ctx, name)
	return err
}

// GetPlatformInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetPlatformInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPlatformInfo(ctx)
	return err
}

// GetPlatformUsageSummary converts echo context to params.
func (w *ServerInterfaceWrapper) GetPlatformUsageSummary(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.admin", "cloud_controller.admin_read_only", "cloud_controller.global_auditor"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPlatformUsageSummary(ctx)
	return err
}

// ListIsolationSegments converts echo context to params.
func (w *ServerInterfaceWrapper) ListIsolationSegments(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListIsolationSegmentsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by: %s", err))
	}

	// ------------- Optional query parameter "created_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_ats", ctx.QueryParams(), &params.CreatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_ats: %s", err))
	}

	// ------------- Optional query parameter "updated_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_ats", ctx.QueryParams(), &params.UpdatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_ats: %s", err))
	}

	// ------------- Optional query parameter "label_selector" -------------

	err = runtime.BindQueryParameter("form", true, false, "label_selector", ctx.QueryParams(), &params.LabelSelector)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter label_selector: %s", err))
	}

	// ------------- Optional query parameter "guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "guids", ctx.QueryParams(), &params.Guids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guids: %s", err))
	}

	// ------------- Optional query parameter "names" -------------

	err = runtime.BindQueryParameter("form", true, false, "names", ctx.QueryParams(), &params.Names)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names: %s", err))
	}

	// ------------- Optional query parameter "organization_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "organization_guids", ctx.QueryParams(), &params.OrganizationGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization_guids: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListIsolationSegments(ctx, params)
	return err
}

// CreateIsolationSegment converts echo context to params.
func (w *ServerInterfaceWrapper) CreateIsolationSegment(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateIsolationSegment(ctx)
	return err
}

// DeleteIsolationSegment converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteIsolationSegment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteIsolationSegment(ctx, guid)
	return err
}

// GetIsolationSegment converts echo context to params.
func (w *ServerInterfaceWrapper) GetIsolationSegment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetIsolationSegment(ctx, guid)
	return err
}

// UpdateIsolationSegment converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateIsolationSegment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateIsolationSegment(ctx, guid)
	return err
}

// ListOrganizationsForIsolationSegment converts echo context to params.
func (w *ServerInterfaceWrapper) ListOrganizationsForIsolationSegment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListOrganizationsForIsolationSegmentParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListOrganizationsForIsolationSegment(ctx, guid, params)
	return err
}

// EntitleOrganizationsForIsolationSegment converts echo context to params.
func (w *ServerInterfaceWrapper) EntitleOrganizationsForIsolationSegment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.EntitleOrganizationsForIsolationSegment(ctx, guid)
	return err
}

// RevokeIsolationSegmentForOrganization converts echo context to params.
func (w *ServerInterfaceWrapper) RevokeIsolationSegmentForOrganization(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	// ------------- Path parameter "org_guid" -------------
	var orgGuid openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "org_guid", runtime.ParamLocationPath, ctx.Param("org_guid"), &orgGuid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter org_guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RevokeIsolationSegmentForOrganization(ctx, guid, orgGuid)
	return err
}

// ListSpacesForIsolationSegment converts echo context to params.
func (w *ServerInterfaceWrapper) ListSpacesForIsolationSegment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListSpacesForIsolationSegmentParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListSpacesForIsolationSegment(ctx, guid, params)
	return err
}

// ListJobs converts echo context to params.
func (w *ServerInterfaceWrapper) ListJobs(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListJobsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by: %s", err))
	}

	// ------------- Optional query parameter "created_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_ats", ctx.QueryParams(), &params.CreatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_ats: %s", err))
	}

	// ------------- Optional query parameter "updated_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_ats", ctx.QueryParams(), &params.UpdatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_ats: %s", err))
	}

	// ------------- Optional query parameter "label_selector" -------------

	err = runtime.BindQueryParameter("form", true, false, "label_selector", ctx.QueryParams(), &params.LabelSelector)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter label_selector: %s", err))
	}

	// ------------- Optional query parameter "guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "guids", ctx.QueryParams(), &params.Guids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guids: %s", err))
	}

	// ------------- Optional query parameter "states" -------------

	err = runtime.BindQueryParameter("form", true, false, "states", ctx.QueryParams(), &params.States)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter states: %s", err))
	}

	// ------------- Optional query parameter "operations" -------------

	err = runtime.BindQueryParameter("form", true, false, "operations", ctx.QueryParams(), &params.Operations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operations: %s", err))
	}

	// ------------- Optional query parameter "resource_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "resource_guids", ctx.QueryParams(), &params.ResourceGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter resource_guids: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListJobs(ctx, params)
	return err
}

// GetJob converts echo context to params.
func (w *ServerInterfaceWrapper) GetJob(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetJob(ctx, guid)
	return err
}

// ListDomainsForOrganization converts echo context to params.
func (w *ServerInterfaceWrapper) ListDomainsForOrganization(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "org_guid" -------------
	var orgGuid openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "org_guid", runtime.ParamLocationPath, ctx.Param("org_guid"), &orgGuid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter org_guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDomainsForOrganizationParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by: %s", err))
	}

	// ------------- Optional query parameter "created_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_ats", ctx.QueryParams(), &params.CreatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_ats: %s", err))
	}

	// ------------- Optional query parameter "updated_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_ats", ctx.QueryParams(), &params.UpdatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_ats: %s", err))
	}

	// ------------- Optional query parameter "guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "guids", ctx.QueryParams(), &params.Guids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guids: %s", err))
	}

	// ------------- Optional query parameter "names" -------------

	err = runtime.BindQueryParameter("form", true, false, "names", ctx.QueryParams(), &params.Names)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListDomainsForOrganization(ctx, orgGuid, params)
	return err
}

// GetDefaultDomain converts echo context to params.
func (w *ServerInterfaceWrapper) GetDefaultDomain(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "org_guid" -------------
	var orgGuid openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "org_guid", runtime.ParamLocationPath, ctx.Param("org_guid"), &orgGuid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter org_guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDefaultDomain(ctx, orgGuid)
	return err
}

// ListPackages converts echo context to params.
func (w *ServerInterfaceWrapper) ListPackages(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPackagesParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by: %s", err))
	}

	// ------------- Optional query parameter "created_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_ats", ctx.QueryParams(), &params.CreatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_ats: %s", err))
	}

	// ------------- Optional query parameter "updated_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_ats", ctx.QueryParams(), &params.UpdatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_ats: %s", err))
	}

	// ------------- Optional query parameter "label_selector" -------------

	err = runtime.BindQueryParameter("form", true, false, "label_selector", ctx.QueryParams(), &params.LabelSelector)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter label_selector: %s", err))
	}

	// ------------- Optional query parameter "guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "guids", ctx.QueryParams(), &params.Guids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guids: %s", err))
	}

	// ------------- Optional query parameter "states" -------------

	err = runtime.BindQueryParameter("form", true, false, "states", ctx.QueryParams(), &params.States)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter states: %s", err))
	}

	// ------------- Optional query parameter "types" -------------

	err = runtime.BindQueryParameter("form", true, false, "types", ctx.QueryParams(), &params.Types)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter types: %s", err))
	}

	// ------------- Optional query parameter "app_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "app_guids", ctx.QueryParams(), &params.AppGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter app_guids: %s", err))
	}

	// ------------- Optional query parameter "space_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "space_guids", ctx.QueryParams(), &params.SpaceGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter space_guids: %s", err))
	}

	// ------------- Optional query parameter "organization_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "organization_guids", ctx.QueryParams(), &params.OrganizationGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization_guids: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListPackages(ctx, params)
	return err
}

// CreatePackage converts echo context to params.
func (w *ServerInterfaceWrapper) CreatePackage(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreatePackage(ctx)
	return err
}

// DeletePackage converts echo context to params.
func (w *ServerInterfaceWrapper) DeletePackage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeletePackage(ctx, guid)
	return err
}

// GetPackage converts echo context to params.
func (w *ServerInterfaceWrapper) GetPackage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPackage(ctx, guid)
	return err
}

// UpdatePackage converts echo context to params.
func (w *ServerInterfaceWrapper) UpdatePackage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdatePackage(ctx, guid)
	return err
}

// DownloadPackageBits converts echo context to params.
func (w *ServerInterfaceWrapper) DownloadPackageBits(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DownloadPackageBits(ctx, guid)
	return err
}

// UploadPackageBits converts echo context to params.
func (w *ServerInterfaceWrapper) UploadPackageBits(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UploadPackageBits(ctx, guid)
	return err
}

// ListRoles converts echo context to params.
func (w *ServerInterfaceWrapper) ListRoles(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRolesParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by: %s", err))
	}

	// ------------- Optional query parameter "created_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_ats", ctx.QueryParams(), &params.CreatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_ats: %s", err))
	}

	// ------------- Optional query parameter "updated_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_ats", ctx.QueryParams(), &params.UpdatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_ats: %s", err))
	}

	// ------------- Optional query parameter "label_selector" -------------

	err = runtime.BindQueryParameter("form", true, false, "label_selector", ctx.QueryParams(), &params.LabelSelector)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter label_selector: %s", err))
	}

	// ------------- Optional query parameter "guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "guids", ctx.QueryParams(), &params.Guids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guids: %s", err))
	}

	// ------------- Optional query parameter "types" -------------

	err = runtime.BindQueryParameter("form", true, false, "types", ctx.QueryParams(), &params.Types)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter types: %s", err))
	}

	// ------------- Optional query parameter "organization_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "organization_guids", ctx.QueryParams(), &params.OrganizationGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization_guids: %s", err))
	}

	// ------------- Optional query parameter "space_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "space_guids", ctx.QueryParams(), &params.SpaceGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter space_guids: %s", err))
	}

	// ------------- Optional query parameter "user_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_guids", ctx.QueryParams(), &params.UserGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_guids: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", true, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListRoles(ctx, params)
	return err
}

// CreateRole converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRole(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateRole(ctx)
	return err
}

// DeleteRole converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteRole(ctx, guid)
	return err
}

// GetRole converts echo context to params.
func (w *ServerInterfaceWrapper) GetRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRoleParams
	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", true, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRole(ctx, guid, params)
	return err
}

// ListRoutes converts echo context to params.
func (w *ServerInterfaceWrapper) ListRoutes(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRoutesParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by: %s", err))
	}

	// ------------- Optional query parameter "created_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_ats", ctx.QueryParams(), &params.CreatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_ats: %s", err))
	}

	// ------------- Optional query parameter "updated_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_ats", ctx.QueryParams(), &params.UpdatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_ats: %s", err))
	}

	// ------------- Optional query parameter "label_selector" -------------

	err = runtime.BindQueryParameter("form", true, false, "label_selector", ctx.QueryParams(), &params.LabelSelector)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter label_selector: %s", err))
	}

	// ------------- Optional query parameter "protocols" -------------

	err = runtime.BindQueryParameter("form", true, false, "protocols", ctx.QueryParams(), &params.Protocols)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter protocols: %s", err))
	}

	// ------------- Optional query parameter "hosts" -------------

	err = runtime.BindQueryParameter("form", true, false, "hosts", ctx.QueryParams(), &params.Hosts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hosts: %s", err))
	}

	// ------------- Optional query parameter "paths" -------------

	err = runtime.BindQueryParameter("form", true, false, "paths", ctx.QueryParams(), &params.Paths)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter paths: %s", err))
	}

	// ------------- Optional query parameter "ports" -------------

	err = runtime.BindQueryParameter("form", true, false, "ports", ctx.QueryParams(), &params.Ports)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ports: %s", err))
	}

	// ------------- Optional query parameter "domain_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "domain_guids", ctx.QueryParams(), &params.DomainGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domain_guids: %s", err))
	}

	// ------------- Optional query parameter "space_guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "space_guids", ctx.QueryParams(), &params.SpaceGuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter space_guids: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListRoutes(ctx, params)
	return err
}

// CreateRoute converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRoute(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateRoute(ctx)
	return err
}

// ListDestinationsForRoute converts echo context to params.
func (w *ServerInterfaceWrapper) ListDestinationsForRoute(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDestinationsForRouteParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListDestinationsForRoute(ctx, guid, params)
	return err
}

// InsertDestinationsForRoute converts echo context to params.
func (w *ServerInterfaceWrapper) InsertDestinationsForRoute(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InsertDestinationsForRoute(ctx, guid)
	return err
}

// ReplaceDestinationsForRoute converts echo context to params.
func (w *ServerInterfaceWrapper) ReplaceDestinationsForRoute(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ReplaceDestinationsForRoute(ctx, guid)
	return err
}

// RemoveDestinationForRoute converts echo context to params.
func (w *ServerInterfaceWrapper) RemoveDestinationForRoute(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	// ------------- Path parameter "destination_guid" -------------
	var destinationGuid openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "destination_guid", runtime.ParamLocationPath, ctx.Param("destination_guid"), &destinationGuid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter destination_guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RemoveDestinationForRoute(ctx, guid, destinationGuid)
	return err
}

// UpdateDestinationProtocolForRoute converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateDestinationProtocolForRoute(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	// ------------- Path parameter "destination_guid" -------------
	var destinationGuid openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "destination_guid", runtime.ParamLocationPath, ctx.Param("destination_guid"), &destinationGuid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter destination_guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateDestinationProtocolForRoute(ctx, guid, destinationGuid)
	return err
}

// DeleteUnmappedRoutesForSpace converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUnmappedRoutesForSpace(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteUnmappedRoutesForSpace(ctx, guid)
	return err
}

// ListUsers converts echo context to params.
func (w *ServerInterfaceWrapper) ListUsers(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUsersParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by: %s", err))
	}

	// ------------- Optional query parameter "created_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_ats", ctx.QueryParams(), &params.CreatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_ats: %s", err))
	}

	// ------------- Optional query parameter "updated_ats" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_ats", ctx.QueryParams(), &params.UpdatedAts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_ats: %s", err))
	}

	// ------------- Optional query parameter "guids" -------------

	err = runtime.BindQueryParameter("form", true, false, "guids", ctx.QueryParams(), &params.Guids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guids: %s", err))
	}

	// ------------- Optional query parameter "usernames" -------------

	err = runtime.BindQueryParameter("form", true, false, "usernames", ctx.QueryParams(), &params.Usernames)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter usernames: %s", err))
	}

	// ------------- Optional query parameter "origins" -------------

	err = runtime.BindQueryParameter("form", true, false, "origins", ctx.QueryParams(), &params.Origins)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter origins: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListUsers(ctx, params)
	return err
}

// CreateUser converts echo context to params.
func (w *ServerInterfaceWrapper) CreateUser(ctx echo.Context) error {
	var err error

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateUser(ctx)
	return err
}

// DeleteUser converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteUser(ctx, guid)
	return err
}

// GetUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUser(ctx, guid)
	return err
}

// UpdateUser converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "guid" -------------
	var guid Guid

	err = runtime.BindStyledParameterWithLocation("simple", false, "guid", runtime.ParamLocationPath, ctx.Param("guid"), &guid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guid: %s", err))
	}

	ctx.Set(OauthScopes, []string{"cloud_controller.write"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateUser(ctx, guid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/", wrapper.GetRoot)
	router.GET(baseURL+"/v3", wrapper.GetRootV3)
	router.GET(baseURL+"/v3/app_usage_events", wrapper.ListAppUsageEvents)
	router.POST(baseURL+"/v3/app_usage_events/actions/destructively_purge_all_and_reseed", wrapper.PurgeAndSeedAppUsageEvents)
	router.GET(baseURL+"/v3/app_usage_events/:guid", wrapper.GetAppUsageEvent)
	router.GET(baseURL+"/v3/apps", wrapper.ListApps)
	router.POST(baseURL+"/v3/apps", wrapper.CreateApp)
	router.GET(baseURL+"/v3/apps/:app_guid/builds", wrapper.ListBuildsForApp)
	router.GET(baseURL+"/v3/apps/:app_guid/features", wrapper.ListAppFeatures)
	router.DELETE(baseURL+"/v3/apps/:guid", wrapper.DeleteApp)
	router.GET(baseURL+"/v3/apps/:guid", wrapper.GetApp)
	router.PATCH(baseURL+"/v3/apps/:guid", wrapper.UpdateApp)
	router.POST(baseURL+"/v3/apps/:guid/actions/restart", wrapper.RestartApp)
	router.POST(baseURL+"/v3/apps/:guid/actions/start", wrapper.StartApp)
	router.POST(baseURL+"/v3/apps/:guid/actions/stop", wrapper.StopApp)
	router.GET(baseURL+"/v3/apps/:guid/droplets/current", wrapper.GetCurrentDropletForApp)
	router.PATCH(baseURL+"/v3/apps/:guid/droplets/current", wrapper.SetCurrentDropletForApp)
	router.PATCH(baseURL+"/v3/apps/:guid/features/:feature_name", wrapper.UpdateAppFeature)
	router.GET(baseURL+"/v3/apps/:guid/packages", wrapper.ListPackagesForApp)
	router.GET(baseURL+"/v3/apps/:guid/revisions", wrapper.ListRevisionsForApp)
	router.GET(baseURL+"/v3/apps/:guid/revisions/deployed", wrapper.ListDeployedRevisionsForApp)
	router.GET(baseURL+"/v3/apps/:guid/revisions/:version", wrapper.GetRevision)
	router.PATCH(baseURL+"/v3/apps/:guid/revisions/:version", wrapper.UpdateRevision)
	router.GET(baseURL+"/v3/apps/:guid/revisions/:version/environment_variables", wrapper.GetEnvironmentVariablesForRevision)
	router.GET(baseURL+"/v3/audit_events", wrapper.ListAuditEvents)
	router.POST(baseURL+"/v3/audit_events", wrapper.CreateAuditEvent)
	router.GET(baseURL+"/v3/audit_events/:guid", wrapper.GetAuditEvent)
	router.GET(baseURL+"/v3/buildpacks", wrapper.ListBuildpacks)
	router.POST(baseURL+"/v3/buildpacks", wrapper.CreateBuildpack)
	router.DELETE(baseURL+"/v3/buildpacks/:guid", wrapper.DeleteBuildpack)
	router.GET(baseURL+"/v3/buildpacks/:guid", wrapper.GetBuildpack)
	router.PATCH(baseURL+"/v3/buildpacks/:guid", wrapper.PpdateBuildpack)
	router.POST(baseURL+"/v3/buildpacks/:guid/upload", wrapper.UploadBuildpack)
	router.GET(baseURL+"/v3/builds", wrapper.ListBuilds)
	router.POST(baseURL+"/v3/builds", wrapper.CreateBuild)
	router.DELETE(baseURL+"/v3/builds/:guid", wrapper.DeleteBuild)
	router.GET(baseURL+"/v3/builds/:guid", wrapper.GetBuild)
	router.PATCH(baseURL+"/v3/builds/:guid", wrapper.UpdateBuild)
	router.GET(baseURL+"/v3/deployments", wrapper.ListDeployments)
	router.POST(baseURL+"/v3/deployments", wrapper.CreateDeployment)
	router.DELETE(baseURL+"/v3/deployments/:guid", wrapper.DeleteDeployment)
	router.GET(baseURL+"/v3/deployments/:guid", wrapper.GetDeployment)
	router.PATCH(baseURL+"/v3/deployments/:guid", wrapper.UpdateDeployment)
	router.POST(baseURL+"/v3/deployments/:guid/actions/cancel", wrapper.CancelDeployment)
	router.POST(baseURL+"/v3/deployments/:guid/actions/continue", wrapper.ContinueDeployment)
	router.GET(baseURL+"/v3/domains", wrapper.ListDomains)
	router.POST(baseURL+"/v3/domains", wrapper.CreateDomain)
	router.DELETE(baseURL+"/v3/domains/:guid", wrapper.DeleteDomain)
	router.GET(baseURL+"/v3/domains/:guid", wrapper.GetDomain)
	router.PATCH(baseURL+"/v3/domains/:guid", wrapper.UpdateDomain)
	router.POST(baseURL+"/v3/domains/:guid/relationships/shared_organizations", wrapper.ShareDomain)
	router.DELETE(baseURL+"/v3/domains/:guid/relationships/shared_organizations/:org_guid", wrapper.UnshareDomain)
	router.GET(baseURL+"/v3/droplets", wrapper.ListDroplets)
	router.POST(baseURL+"/v3/droplets", wrapper.CreateDroplet)
	router.DELETE(baseURL+"/v3/droplets/:droplet_guid", wrapper.DeleteDroplet)
	router.GET(baseURL+"/v3/droplets/:droplet_guid", wrapper.GetDroplet)
	router.PATCH(baseURL+"/v3/droplets/:droplet_guid", wrapper.UpdateDroplet)
	router.GET(baseURL+"/v3/droplets/:droplet_guid/download", wrapper.DownloadDroplet)
	router.POST(baseURL+"/v3/droplets/:droplet_guid/upload", wrapper.UploadDroplet)
	router.GET(baseURL+"/v3/environment_variable_groups/running", wrapper.GetRunningEnvironmentVariableGroup)
	router.PATCH(baseURL+"/v3/environment_variable_groups/running", wrapper.UpdateRunningEnvironmentVariableGroup)
	router.GET(baseURL+"/v3/environment_variable_groups/staging", wrapper.GetStagingEnvironmentVariableGroup)
	router.PATCH(baseURL+"/v3/environment_variable_groups/staging", wrapper.UpdateStagingEnvironmentVariableGroup)
	router.GET(baseURL+"/v3/feature_flags", wrapper.ListFeatureFlags)
	router.POST(baseURL+"/v3/feature_flags", wrapper.CreateFeatureFlag)
	router.GET(baseURL+"/v3/feature_flags/:name", wrapper.GetFeatureFlag)
	router.PATCH(baseURL+"/v3/feature_flags/:name", wrapper.UpdateFeatureFlag)
	router.GET(baseURL+"/v3/info", wrapper.GetPlatformInfo)
	router.GET(baseURL+"/v3/info/usage_summary", wrapper.GetPlatformUsageSummary)
	router.GET(baseURL+"/v3/isolation_segments", wrapper.ListIsolationSegments)
	router.POST(baseURL+"/v3/isolation_segments", wrapper.CreateIsolationSegment)
	router.DELETE(baseURL+"/v3/isolation_segments/:guid", wrapper.DeleteIsolationSegment)
	router.GET(baseURL+"/v3/isolation_segments/:guid", wrapper.GetIsolationSegment)
	router.PATCH(baseURL+"/v3/isolation_segments/:guid", wrapper.UpdateIsolationSegment)
	router.GET(baseURL+"/v3/isolation_segments/:guid/relationships/organizations", wrapper.ListOrganizationsForIsolationSegment)
	router.POST(baseURL+"/v3/isolation_segments/:guid/relationships/organizations", wrapper.EntitleOrganizationsForIsolationSegment)
	router.DELETE(baseURL+"/v3/isolation_segments/:guid/relationships/organizations/:org_guid", wrapper.RevokeIsolationSegmentForOrganization)
	router.GET(baseURL+"/v3/isolation_segments/:guid/relationships/spaces", wrapper.ListSpacesForIsolationSegment)
	router.GET(baseURL+"/v3/jobs", wrapper.ListJobs)
	router.GET(baseURL+"/v3/jobs/:guid", wrapper.GetJob)
	router.GET(baseURL+"/v3/organizations/:org_guid/domains", wrapper.ListDomainsForOrganization)
	router.GET(baseURL+"/v3/organizations/:org_guid/domains/default", wrapper.GetDefaultDomain)
	router.GET(baseURL+"/v3/packages", wrapper.ListPackages)
	router.POST(baseURL+"/v3/packages", wrapper.CreatePackage)
	router.DELETE(baseURL+"/v3/packages/:guid", wrapper.DeletePackage)
	router.GET(baseURL+"/v3/packages/:guid", wrapper.GetPackage)
	router.PATCH(baseURL+"/v3/packages/:guid", wrapper.UpdatePackage)
	router.GET(baseURL+"/v3/packages/:guid/download", wrapper.DownloadPackageBits)
	router.POST(baseURL+"/v3/packages/:guid/upload", wrapper.UploadPackageBits)
	router.GET(baseURL+"/v3/roles", wrapper.ListRoles)
	router.POST(baseURL+"/v3/roles", wrapper.CreateRole)
	router.DELETE(baseURL+"/v3/roles/:guid", wrapper.DeleteRole)
	router.GET(baseURL+"/v3/roles/:guid", wrapper.GetRole)
	router.GET(baseURL+"/v3/routes", wrapper.ListRoutes)
	router.POST(baseURL+"/v3/routes", wrapper.CreateRoute)
	router.GET(baseURL+"/v3/routes/:guid/destinations", wrapper.ListDestinationsForRoute)
	router.POST(baseURL+"/v3/routes/:guid/destinations", wrapper.InsertDestinationsForRoute)
	router.PUT(baseURL+"/v3/routes/:guid/destinations", wrapper.ReplaceDestinationsForRoute)
	router.DELETE(baseURL+"/v3/routes/:guid/destinations/:destination_guid", wrapper.RemoveDestinationForRoute)
	router.PATCH(baseURL+"/v3/routes/:guid/destinations/:destination_guid", wrapper.UpdateDestinationProtocolForRoute)
	router.DELETE(baseURL+"/v3/spaces/:guid/routes", wrapper.DeleteUnmappedRoutesForSpace)
	router.GET(baseURL+"/v3/users", wrapper.ListUsers)
	router.POST(baseURL+"/v3/users", wrapper.CreateUser)
	router.DELETE(baseURL+"/v3/users/:guid", wrapper.DeleteUser)
	router.GET(baseURL+"/v3/users/:guid", wrapper.GetUser)
	router.PATCH(baseURL+"/v3/users/:guid", wrapper.UpdateUser)

}
