//go:build go1.22

// Package gen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package gen

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// Link defines model for link.
type Link struct {
	// Href The URI reference to the resource.
	Href string `json:"href"`

	// Meta Metadata related to the resource.
	Meta *Link_Meta `json:"meta,omitempty"`
}

// Link_Meta Metadata related to the resource.
type Link_Meta struct {
	// Experimental Indicates whether the linked API is experimental.
	Experimental *bool `json:"experimental,omitempty"`

	// HostKeyFingerprint The fingerprint of the host's public key, used for security verification.
	HostKeyFingerprint *string `json:"host_key_fingerprint,omitempty"`

	// OauthClient The OAuth client identifier used for authentication purposes.
	OauthClient *string `json:"oauth_client,omitempty"`

	// Version The version identifier of the referenced resource.
	Version              *string                `json:"version,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Root defines model for root.
type Root struct {
	// Links A collection of API components and their root endpoints.
	Links struct {
		AppSsh            *Link `json:"app_ssh,omitempty"`
		CloudControllerV2 *Link `json:"cloud_controller_v2,omitempty"`
		CloudControllerV3 *Link `json:"cloud_controller_v3,omitempty"`
		Credhub           *Link `json:"credhub,omitempty"`
		Health            *Link `json:"health,omitempty"`
		LogCache          *Link `json:"log_cache,omitempty"`
		LogStream         *Link `json:"log_stream,omitempty"`
		Logging           *Link `json:"logging,omitempty"`
		Login             *Link `json:"login,omitempty"`
		NetworkPolicyV0   *Link `json:"network_policy_v0,omitempty"`
		NetworkPolicyV1   *Link `json:"network_policy_v1,omitempty"`
		Routing           *Link `json:"routing,omitempty"`
		Self              *Link `json:"self,omitempty"`
		Uaa               *Link `json:"uaa,omitempty"`
		Version           *Link `json:"version,omitempty"`
	} `json:"links"`
}

// V3 defines model for v3.
type V3 struct {
	// Links A collection of Cloud Controller V3 components and their root endpoints.
	Links struct {
		Apps                      *Link `json:"apps,omitempty"`
		Buildpacks                *Link `json:"buildpacks,omitempty"`
		Builds                    *Link `json:"builds,omitempty"`
		Deployments               *Link `json:"deployments,omitempty"`
		Domains                   *Link `json:"domains,omitempty"`
		Droplets                  *Link `json:"droplets,omitempty"`
		EnvironmentVariableGroups *Link `json:"environment_variable_groups,omitempty"`
		FeatureFlags              *Link `json:"feature_flags,omitempty"`
		Info                      *Link `json:"info,omitempty"`
		IsolationSegments         *Link `json:"isolation_segments,omitempty"`
		Manifests                 *Link `json:"manifests,omitempty"`
		OrganizationQuotas        *Link `json:"organization_quotas,omitempty"`
		Organizations             *Link `json:"organizations,omitempty"`
		Packages                  *Link `json:"packages,omitempty"`
		PrivateDomains            *Link `json:"private_domains,omitempty"`
		Processes                 *Link `json:"processes,omitempty"`
		ResourceMatches           *Link `json:"resource_matches,omitempty"`
		Resources                 *Link `json:"resources,omitempty"`
		Revisions                 *Link `json:"revisions,omitempty"`
		Roles                     *Link `json:"roles,omitempty"`
		RouteMappings             *Link `json:"route_mappings,omitempty"`
		Routes                    *Link `json:"routes,omitempty"`
		SecurityGroups            *Link `json:"security_groups,omitempty"`
		Self                      *Link `json:"self,omitempty"`
		ServiceBrokers            *Link `json:"service_brokers,omitempty"`
		ServiceCredentialBindings *Link `json:"service_credential_bindings,omitempty"`
		ServiceInstances          *Link `json:"service_instances,omitempty"`
		ServiceOfferings          *Link `json:"service_offerings,omitempty"`
		ServicePlans              *Link `json:"service_plans,omitempty"`
		SharedDomains             *Link `json:"shared_domains,omitempty"`
		Sidecars                  *Link `json:"sidecars,omitempty"`
		SpaceQuotas               *Link `json:"space_quotas,omitempty"`
		Spaces                    *Link `json:"spaces,omitempty"`
		Stacks                    *Link `json:"stacks,omitempty"`
		Tasks                     *Link `json:"tasks,omitempty"`
		Users                     *Link `json:"users,omitempty"`
	} `json:"links"`
}

// Getter for additional properties for Link_Meta. Returns the specified
// element and whether it was found
func (a Link_Meta) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Link_Meta
func (a *Link_Meta) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Link_Meta to handle AdditionalProperties
func (a *Link_Meta) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["experimental"]; found {
		err = json.Unmarshal(raw, &a.Experimental)
		if err != nil {
			return fmt.Errorf("error reading 'experimental': %w", err)
		}
		delete(object, "experimental")
	}

	if raw, found := object["host_key_fingerprint"]; found {
		err = json.Unmarshal(raw, &a.HostKeyFingerprint)
		if err != nil {
			return fmt.Errorf("error reading 'host_key_fingerprint': %w", err)
		}
		delete(object, "host_key_fingerprint")
	}

	if raw, found := object["oauth_client"]; found {
		err = json.Unmarshal(raw, &a.OauthClient)
		if err != nil {
			return fmt.Errorf("error reading 'oauth_client': %w", err)
		}
		delete(object, "oauth_client")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Link_Meta to handle AdditionalProperties
func (a Link_Meta) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Experimental != nil {
		object["experimental"], err = json.Marshal(a.Experimental)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'experimental': %w", err)
		}
	}

	if a.HostKeyFingerprint != nil {
		object["host_key_fingerprint"], err = json.Marshal(a.HostKeyFingerprint)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'host_key_fingerprint': %w", err)
		}
	}

	if a.OauthClient != nil {
		object["oauth_client"], err = json.Marshal(a.OauthClient)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'oauth_client': %w", err)
		}
	}

	if a.Version != nil {
		object["version"], err = json.Marshal(a.Version)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'version': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get API root metadata
	// (GET /)
	GetApiRoot(w http.ResponseWriter, r *http.Request)
	// Get API root
	// (GET /v3)
	GetApiV3Root(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetApiRoot operation middleware
func (siw *ServerInterfaceWrapper) GetApiRoot(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetApiRoot(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetApiV3Root operation middleware
func (siw *ServerInterfaceWrapper) GetApiV3Root(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetApiV3Root(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/", wrapper.GetApiRoot)
	m.HandleFunc("GET "+options.BaseURL+"/v3", wrapper.GetApiV3Root)

	return m
}
